

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Makefile概念入门 &mdash; MySummary 1.0 文档</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="ARM服务器进展小结" href="ARM服务器进展小结.html" />
    <link rel="prev" title="架构的存在性" href="架构的存在性.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../README.html" class="icon icon-home"> MySummary
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../道德经直译/README.html">《道德经》直译</a></li>
<li class="toctree-l1"><a class="reference internal" href="../花朵的温室/README.html">花朵的温室</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="README.html">软件架构设计</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="什么是软件架构.html">什么是软件架构</a></li>
<li class="toctree-l2"><a class="reference internal" href="大型软件架构设计.html">大型软件架构设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="架构师具体设计什么.html">架构师具体设计什么</a></li>
<li class="toctree-l2"><a class="reference internal" href="Use Case图有什么用？.html">Use Case图有什么用？</a></li>
<li class="toctree-l2"><a class="reference internal" href="使用软件的四种方法.html">使用软件的四种方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="从单元测试理解软件.html">从单元测试理解软件</a></li>
<li class="toctree-l2"><a class="reference internal" href="名可名.html">名可名</a></li>
<li class="toctree-l2"><a class="reference internal" href="小国寡民.html">小国寡民</a></li>
<li class="toctree-l2"><a class="reference internal" href="需求分析的中心思路.html">需求分析的中心思路</a></li>
<li class="toctree-l2"><a class="reference internal" href="关于自然语言编程的方向问题.html">关于自然语言编程的方向问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="反者道之动——欣赏架构设计的基本逻辑.html">反者道之动——欣赏架构设计的基本逻辑</a></li>
<li class="toctree-l2"><a class="reference internal" href="让代码变立体.html">让代码变立体</a></li>
<li class="toctree-l2"><a class="reference internal" href="生成优秀的架构.html">生成优秀的架构</a></li>
<li class="toctree-l2"><a class="reference internal" href="分支设计要领.html">分支设计要领</a></li>
<li class="toctree-l2"><a class="reference internal" href="怎样做项目管理.html">怎样做项目管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="谈谈子女教育问题.html">谈谈子女教育问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="两种基本的构架表述方法.html">两种基本的构架表述方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="弱者道之用——谈技术工作中的守弱问题.html">弱者道之用——谈技术工作中的守弱问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="在Linux下做性能分析.html">在Linux下做性能分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="架构设计的0层逻辑.html">架构设计的0层逻辑</a></li>
<li class="toctree-l2"><a class="reference internal" href="解耦设计.html">解耦设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="怎么做高层设计.html">怎么做高层设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="理解架构版本.html">理解架构版本</a></li>
<li class="toctree-l2"><a class="reference internal" href="PCIE总线的保序模型.html">PCIE总线的保序模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="做与不做都是战略.html">做与不做都是战略</a></li>
<li class="toctree-l2"><a class="reference internal" href="海洋战术式的软件设计方法.html">海洋战术式的软件设计方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="解耦和不解耦.html">解耦和不解耦</a></li>
<li class="toctree-l2"><a class="reference internal" href="再谈“守弱”.html">再谈“守弱”</a></li>
<li class="toctree-l2"><a class="reference internal" href="互斥算法设计.html">互斥算法设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="英文版本的“弱者道之用”.html">英文版本的“弱者道之用”</a></li>
<li class="toctree-l2"><a class="reference internal" href="什么是“守”.html">什么是“守”</a></li>
<li class="toctree-l2"><a class="reference internal" href="从用户功能开始构架系统框架.html">从用户功能开始构架系统框架</a></li>
<li class="toctree-l2"><a class="reference internal" href="Linux发行版的库软件包组织.html">Linux发行版的库软件包组织</a></li>
<li class="toctree-l2"><a class="reference internal" href="地址空间的故事.html">地址空间的故事</a></li>
<li class="toctree-l2"><a class="reference internal" href="工作和读书有什么不同.html">工作和读书有什么不同</a></li>
<li class="toctree-l2"><a class="reference internal" href="怎样快速调试Linux内核.html">怎样快速调试Linux内核</a></li>
<li class="toctree-l2"><a class="reference internal" href="架构设计中的“少了”和“多了”的问题.html">架构设计中的“少了”和“多了”的问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="Linux iommu和vfio概念空间解构.html">Linux iommu和vfio概念空间解构</a></li>
<li class="toctree-l2"><a class="reference internal" href="怎样做代码Review.html">怎样做代码Review</a></li>
<li class="toctree-l2"><a class="reference internal" href="怎样做客户访谈.html">怎样做客户访谈</a></li>
<li class="toctree-l2"><a class="reference internal" href="RancherOS架构分析.html">RancherOS架构分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="再谈什么是软件架构.html">再谈什么是软件架构</a></li>
<li class="toctree-l2"><a class="reference internal" href="大道曰守，当时曰行.html">大道曰守，当时曰行</a></li>
<li class="toctree-l2"><a class="reference internal" href="不为天下先.html">不为天下先</a></li>
<li class="toctree-l2"><a class="reference internal" href="关于AI的胡说八道.html">关于AI的胡说八道</a></li>
<li class="toctree-l2"><a class="reference internal" href="学习本质？.html">学习本质？</a></li>
<li class="toctree-l2"><a class="reference internal" href="“设计的流程”和“代码的流程”.html">“设计的流程”和“代码的流程”</a></li>
<li class="toctree-l2"><a class="reference internal" href="概要设计不是代码.html">概要设计不是代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="“病病”.html">“病病”</a></li>
<li class="toctree-l2"><a class="reference internal" href="关于架构师的爱恨情仇——《黑客帝国》世界观解读.html">关于架构师的爱恨情仇——《黑客帝国》世界观解读</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio-mdev逻辑空间分析.html">vfio-mdev逻辑空间分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="Linux Socket 0拷贝特性.html">Linux Socket 0拷贝特性</a></li>
<li class="toctree-l2"><a class="reference internal" href="用户态DMA的问题.html">用户态DMA的问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="Multiprocess Support for Linux IOMMU driver.html">Multiprocess Support for Linux IOMMU driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="Linux RAS特性分析.html">Linux RAS特性分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="写论文.html">写论文</a></li>
<li class="toctree-l2"><a class="reference internal" href="基于“语义”编程.html">基于“语义”编程</a></li>
<li class="toctree-l2"><a class="reference internal" href="从学习assert的用法开始理解如何写“专业的程序”.html">从学习assert的用法开始理解如何写“专业的程序”</a></li>
<li class="toctree-l2"><a class="reference internal" href="架构的存在性.html">架构的存在性</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Makefile概念入门</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">版本</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">介绍</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">关于程序编译</a></li>
<li class="toctree-l3"><a class="reference internal" href="#phony">phony依赖</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">宏</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">头文件问题</a></li>
<li class="toctree-l3"><a class="reference internal" href="#autoconf">autoconf</a></li>
<li class="toctree-l3"><a class="reference internal" href="#automake">automake</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">关于架构的进一步讨论</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">总结</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ARM服务器进展小结.html">ARM服务器进展小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="怎么做初步的需求分析.html">怎么做初步的需求分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="关于设计方案中的逻辑链问题.html">关于设计方案中的逻辑链问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="从逻辑链问题讨论怎么做高层设计.html">从逻辑链问题讨论怎么做高层设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="工程逻辑链.html">工程逻辑链</a></li>
<li class="toctree-l2"><a class="reference internal" href="为什么你会在你的数据中心中部署ARM服务器.html">为什么你会在你的数据中心中部署ARM服务器</a></li>
<li class="toctree-l2"><a class="reference internal" href="如何为libvirt设置虚拟主机.html">如何为libvirt设置虚拟主机</a></li>
<li class="toctree-l2"><a class="reference internal" href="给普通人解释Spectre和Meltdown安全漏洞.html">给普通人解释Spectre和Meltdown安全漏洞</a></li>
<li class="toctree-l2"><a class="reference internal" href="给程序员解释Spectre和Meltdown漏洞.html">给程序员解释Spectre和Meltdown漏洞</a></li>
<li class="toctree-l2"><a class="reference internal" href="Is retpoline really safe.html">Is retpoline really safe?</a></li>
<li class="toctree-l2"><a class="reference internal" href="逻辑链，道，学和架构工作的本质.html">逻辑链，道，学和架构工作的本质</a></li>
<li class="toctree-l2"><a class="reference internal" href="Serverless是什么——谈如何捕获一个特性的架构本质.html">Serverless是什么——谈如何捕获一个特性的架构本质</a></li>
<li class="toctree-l2"><a class="reference internal" href="道法自然.html">道法自然</a></li>
<li class="toctree-l2"><a class="reference internal" href="自然，守弱和Plan B.html">自然，守弱和Plan B</a></li>
<li class="toctree-l2"><a class="reference internal" href="守弱的内涵和外延.html">守弱的内涵和外延</a></li>
<li class="toctree-l2"><a class="reference internal" href="找到道法自然的“度”.html">找到道法自然的“度”</a></li>
<li class="toctree-l2"><a class="reference internal" href="Specification的写法问题.html">Specification的写法问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="小姐和丫鬟的故事.html">小姐和丫鬟的故事</a></li>
<li class="toctree-l2"><a class="reference internal" href="知不知.html">知不知</a></li>
<li class="toctree-l2"><a class="reference internal" href="PCIE总线的地址问题.html">PCIE总线的地址问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="气和深度学习.html">气和深度学习</a></li>
<li class="toctree-l2"><a class="reference internal" href="单元测试的效果问题.html">单元测试的效果问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="Requirement Analyzing vs. Voting.html">Requirement Analyzing vs. Voting</a></li>
<li class="toctree-l2"><a class="reference internal" href="抽离设计逻辑.html">抽离设计逻辑</a></li>
<li class="toctree-l2"><a class="reference internal" href="盗夸.html">盗夸</a></li>
<li class="toctree-l2"><a class="reference internal" href="抽象还是不抽象的问题.html">抽象还是不抽象的问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tegra TX2一瞥.html">Tegra TX2一瞥</a></li>
<li class="toctree-l2"><a class="reference internal" href="Progress and confusion of the IOMMU name space.html">Progress and confusion of the IOMMU name space</a></li>
<li class="toctree-l2"><a class="reference internal" href="一样还是不一样.html">一样还是不一样</a></li>
<li class="toctree-l2"><a class="reference internal" href="运营还是交付.html">运营还是交付</a></li>
<li class="toctree-l2"><a class="reference internal" href="科普一下GPL和开源软件.html">科普一下GPL和开源软件</a></li>
<li class="toctree-l2"><a class="reference internal" href="怎么确定道.html">怎么确定道</a></li>
<li class="toctree-l2"><a class="reference internal" href="回调还是直调.html">回调还是直调</a></li>
<li class="toctree-l2"><a class="reference internal" href="接口的封装层次问题.html">接口的封装层次问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="git的基本架构欣赏.html">git的基本架构欣赏</a></li>
<li class="toctree-l2"><a class="reference internal" href="让设计自生.html">让设计自生</a></li>
<li class="toctree-l2"><a class="reference internal" href="架构控制的从权问题.html">架构控制的从权问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="设计的需求问题.html">设计的需求问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="性能优化的目标问题.html">性能优化的目标问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="加速器和其他硬件的区别.html">加速器和其他硬件的区别</a></li>
<li class="toctree-l2"><a class="reference internal" href="君子与其练达不若朴鲁与其曲谨不若疏狂.html">君子与其练达不若朴鲁与其曲谨不若疏狂</a></li>
<li class="toctree-l2"><a class="reference internal" href="有无之道——一个新的软件架构定义.html">有无之道——一个新的软件架构定义</a></li>
<li class="toctree-l2"><a class="reference internal" href="什么是管理.html">什么是管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="从香农熵谈设计文档写作.html">从香农熵谈设计文档写作</a></li>
<li class="toctree-l2"><a class="reference internal" href="YVR18资料关注点.html">YVR18资料关注点</a></li>
<li class="toctree-l2"><a class="reference internal" href="理解关联.html">理解关联</a></li>
<li class="toctree-l2"><a class="reference internal" href="如何撰写技术交底书.html">如何撰写技术交底书</a></li>
<li class="toctree-l2"><a class="reference internal" href="infiniband概念空间分析.html">infiniband概念空间分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="再谈什么是高层设计.html">再谈什么是高层设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="再谈“法自然”的设计思路.html">再谈“法自然”的设计思路</a></li>
<li class="toctree-l2"><a class="reference internal" href="设计规范.html">设计规范</a></li>
<li class="toctree-l2"><a class="reference internal" href="开源交付.html">开源交付</a></li>
<li class="toctree-l2"><a class="reference internal" href="道纪.html">道纪</a></li>
<li class="toctree-l2"><a class="reference internal" href="X86上的ARM Linux调试环境.html">X86上的ARM Linux调试环境</a></li>
<li class="toctree-l2"><a class="reference internal" href="IOMMU的现状和发展.html">IOMMU的现状和发展</a></li>
<li class="toctree-l2"><a class="reference internal" href="单元测试的强与弱问题.html">单元测试的强与弱问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="做事，做名，绩效主义，以及架构战略.html">做事，做名，绩效主义，以及架构战略</a></li>
<li class="toctree-l2"><a class="reference internal" href="没有规则的规则.html">没有规则的规则</a></li>
<li class="toctree-l2"><a class="reference internal" href="大成若缺.html">大成若缺</a></li>
<li class="toctree-l2"><a class="reference internal" href="非易失内存随想.html">非易失内存随想</a></li>
<li class="toctree-l2"><a class="reference internal" href="参考平台.html">参考平台</a></li>
<li class="toctree-l2"><a class="reference internal" href="一个例子：名的边界效应.html">一个例子：名的边界效应</a></li>
<li class="toctree-l2"><a class="reference internal" href="抽象问题的模型.html">抽象问题的模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="另一个例子：名的边界效应.html">另一个例子：名的边界效应</a></li>
<li class="toctree-l2"><a class="reference internal" href="Zircon架构简单分析1: Overview.html">Zircon架构简单分析1: Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="在qemu中模拟设备.html">在qemu中模拟设备</a></li>
<li class="toctree-l2"><a class="reference internal" href="国产操作系统问题.html">国产操作系统问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="软件飞线.html">软件飞线</a></li>
<li class="toctree-l2"><a class="reference internal" href="状态机方法.html">状态机方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="一些典型的架构设计错误.html">一些典型的架构设计错误</a></li>
<li class="toctree-l2"><a class="reference internal" href="从CPU和TPU的不同语言抽象看抽象原则.html">从CPU和TPU的不同语言抽象看抽象原则</a></li>
<li class="toctree-l2"><a class="reference internal" href="限制管理.html">限制管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="WarpDrive as a General Heterogeneous Platform.html">WarpDrive as a General Heterogeneous Platform</a></li>
<li class="toctree-l2"><a class="reference internal" href="Multiarch概念调查.html">Multiarch概念调查</a></li>
<li class="toctree-l2"><a class="reference internal" href="ARM NUC.html">ARM NUC</a></li>
<li class="toctree-l2"><a class="reference internal" href="UML有没有用.html">UML有没有用</a></li>
<li class="toctree-l2"><a class="reference internal" href="推演一个Buffer分配的语法设计.html">推演一个Buffer分配的语法设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="架构师和项目经理的基本职责问题.html">架构师和项目经理的基本职责问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="锁使用设计.html">锁使用设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="从内核终止用户态程序的IO访问.html">从内核终止用户态程序的IO访问</a></li>
<li class="toctree-l2"><a class="reference internal" href="epoll和select.html">epoll和select</a></li>
<li class="toctree-l2"><a class="reference internal" href="状态机退出方法.html">状态机退出方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="不为天下先2.html">不为天下先2</a></li>
<li class="toctree-l2"><a class="reference internal" href="设计逻辑和代码逻辑.html">设计逻辑和代码逻辑</a></li>
<li class="toctree-l2"><a class="reference internal" href="流水线深度.html">流水线深度</a></li>
<li class="toctree-l2"><a class="reference internal" href="谁是主线？.html">谁是主线？</a></li>
<li class="toctree-l2"><a class="reference internal" href="理解指令集.html">理解指令集</a></li>
<li class="toctree-l2"><a class="reference internal" href="给使用设备的进程发信号.html">给使用设备的进程发信号</a></li>
<li class="toctree-l2"><a class="reference internal" href="Linux设备异常复位逻辑分析.html">Linux设备异常复位逻辑分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="投资开源社区的基本逻辑.html">投资开源社区的基本逻辑</a></li>
<li class="toctree-l2"><a class="reference internal" href="一个Linux死锁信息分析.html">一个Linux死锁信息分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="如何说谎.html">如何说谎</a></li>
<li class="toctree-l2"><a class="reference internal" href="代码生成器.html">代码生成器</a></li>
<li class="toctree-l2"><a class="reference internal" href="弟子规：美国军方禁止在C语言程序中使用malloc.html">弟子规：美国军方禁止在C语言程序中使用malloc</a></li>
<li class="toctree-l2"><a class="reference internal" href="自下而上和自上而下的设计.html">自下而上和自上而下的设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="正面竞争.html">正面竞争</a></li>
<li class="toctree-l2"><a class="reference internal" href="不知为美.html">不知为美</a></li>
<li class="toctree-l2"><a class="reference internal" href="高层封装的设计战略.html">高层封装的设计战略</a></li>
<li class="toctree-l2"><a class="reference internal" href="产业生态的原理和作用.html">产业生态的原理和作用</a></li>
<li class="toctree-l2"><a class="reference internal" href="弯道问题.html">弯道问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="无名概念的深入探讨.html">无名概念的深入探讨</a></li>
<li class="toctree-l2"><a class="reference internal" href="解释On-Chip Debug和Off-Chip Debug.html">解释On-Chip Debug和Off-Chip Debug</a></li>
<li class="toctree-l2"><a class="reference internal" href="接口和名称空间辨识.html">接口和名称空间辨识</a></li>
<li class="toctree-l2"><a class="reference internal" href="RISCV WMO和TSO具体解决什么问题.html">RISCV WMO和TSO具体解决什么问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="利益链.html">利益链</a></li>
<li class="toctree-l2"><a class="reference internal" href="从C的for和Python的for聊起.html">从C的for和Python的for聊起</a></li>
<li class="toctree-l2"><a class="reference internal" href="安全建模问题讨论.html">安全建模问题讨论</a></li>
<li class="toctree-l2"><a class="reference internal" href="Accelerator vs. Co-processor.html">Accelerator vs. Co-processor</a></li>
<li class="toctree-l2"><a class="reference internal" href="一个逻辑空间控制的例子：uacce生命周期管理.html">一个逻辑空间控制的例子：uacce生命周期管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="软件构架设计的入题角度问题.html">软件构架设计的入题角度问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="接口分层的问题.html">接口分层的问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="对Cache Coherence的重理解.html">对Cache Coherence的重理解</a></li>
<li class="toctree-l2"><a class="reference internal" href="接口定义的工作模型.html">接口定义的工作模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="Linux_net和net-next分支的维护策略.html">Linux net和net-next分支的维护策略</a></li>
<li class="toctree-l2"><a class="reference internal" href="WarpDrive用户态方案重构建议.html">WarpDrive用户态方案重构建议</a></li>
<li class="toctree-l2"><a class="reference internal" href="主线逻辑.html">主线逻辑</a></li>
<li class="toctree-l2"><a class="reference internal" href="架构设计的粗与细问题.html">架构设计的粗与细问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="狂人日记读后感——名称空间囚笼.html">狂人日记读后感——名称空间囚笼</a></li>
<li class="toctree-l2"><a class="reference internal" href="写程序和写小说的区别.html">写程序和写小说的区别</a></li>
<li class="toctree-l2"><a class="reference internal" href="再谈《弟子规》问题.html">再谈《弟子规》问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="理解弱内存顺序模型.html">理解弱内存顺序模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="思维上的洞2.html">思维上的洞2</a></li>
<li class="toctree-l2"><a class="reference internal" href="后软件时代和技术沙盘陷阱.html">后软件时代和技术沙盘陷阱</a></li>
<li class="toctree-l2"><a class="reference internal" href="怎么做项目管理2.html">怎么做项目管理2</a></li>
<li class="toctree-l2"><a class="reference internal" href="语言的控制力问题.html">语言的控制力问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="分享我的Linux内核开发环境.html">分享我的Linux内核开发环境</a></li>
<li class="toctree-l2"><a class="reference internal" href="开发视图.html">开发视图</a></li>
<li class="toctree-l2"><a class="reference internal" href="概念视图.html">概念视图</a></li>
<li class="toctree-l2"><a class="reference internal" href="处理视图.html">处理视图</a></li>
<li class="toctree-l2"><a class="reference internal" href="语言控制力问题.html">语言控制力问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="新手设计文档典型错误.html">新手设计文档典型错误</a></li>
<li class="toctree-l2"><a class="reference internal" href="讨论：OpenCL2.0SVM有什么好？.html">讨论：OpenCL2.0SVM有什么好？</a></li>
<li class="toctree-l2"><a class="reference internal" href="设计逻辑的细致和严密问题.html">设计逻辑的细致和严密问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="逻辑的平面和立体问题.html">逻辑的平面和立体问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="自由和约束.html">自由和约束</a></li>
<li class="toctree-l2"><a class="reference internal" href="给非专业人士介绍架构设计工作.html">给非专业人士介绍架构设计工作</a></li>
<li class="toctree-l2"><a class="reference internal" href="AML工作原理快速调研.html">AML工作原理快速调研</a></li>
<li class="toctree-l2"><a class="reference internal" href="qemu_PCIe总线结构.html">qemu PCIe总线结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="ARM64_Linux_Kernel_5.7无法GDB调试问题.html">ARM64 Linux Kernel 5.7无法GDB调试问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="分层抽象.html">分层抽象</a></li>
<li class="toctree-l2"><a class="reference internal" href="见素抱朴：一个关于交付的例子.html">见素抱朴：一个关于交付的例子</a></li>
<li class="toctree-l2"><a class="reference internal" href="三个锦囊.html">三个锦囊</a></li>
<li class="toctree-l2"><a class="reference internal" href="多核MMU和ASID管理逻辑.html">多核MMU和ASID管理逻辑</a></li>
<li class="toctree-l2"><a class="reference internal" href="PMA和PA方案对比.html">PMA和PA方案对比</a></li>
<li class="toctree-l2"><a class="reference internal" href="真假架构设计.html">真假架构设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="怎样写标准提案.html">怎样写标准提案</a></li>
<li class="toctree-l2"><a class="reference internal" href="安全问题的本质.html">安全问题的本质</a></li>
<li class="toctree-l2"><a class="reference internal" href="名称内涵的发展.html">名称内涵的发展</a></li>
<li class="toctree-l2"><a class="reference internal" href="标准和设计的区别.html">标准和设计的区别</a></li>
<li class="toctree-l2"><a class="reference internal" href="cond_mutex模型.html">cond/mutex模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="一个例子：架构的重要性和从权.html">一个例子：架构的重要性和从权</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvdimm_AD模式的内核应用模型.html">nvdimm AD模式的内核应用模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="早期架构设计问题.html">早期架构设计问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="所谓内部设计.html">所谓内部设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="“知不知”如何影响决策的？.html">“知不知”如何影响决策的？</a></li>
<li class="toctree-l2"><a class="reference internal" href="“优秀架构设计”.html">“优秀架构设计”</a></li>
<li class="toctree-l2"><a class="reference internal" href="Linux_Kernel架构赏析.html">Linux Kernel架构赏析</a></li>
<li class="toctree-l2"><a class="reference internal" href="说说对协程的看法.html">说说对协程的看法</a></li>
<li class="toctree-l2"><a class="reference internal" href="架构设计和实施的对齐和同步问题.html">架构设计和实施的对齐和同步问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="一个关于4+1视图的案例：从概念视图开始.html">一个关于4+1视图的案例：从概念视图开始</a></li>
<li class="toctree-l2"><a class="reference internal" href="“硬件状态机”.html">“硬件状态机”</a></li>
<li class="toctree-l2"><a class="reference internal" href="设计的减熵原理.html">设计的减熵原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="binfmt概念空间建模.html">binfmt概念空间建模</a></li>
<li class="toctree-l2"><a class="reference internal" href="架构设计入门知识.html">架构设计入门知识</a></li>
<li class="toctree-l2"><a class="reference internal" href="架构设计的大忌：我没错.html">架构设计的大忌：我没错</a></li>
<li class="toctree-l2"><a class="reference internal" href="“解决方案”.html">“解决方案”</a></li>
<li class="toctree-l2"><a class="reference internal" href="讨论一下eBPF.html">讨论一下eBPF</a></li>
<li class="toctree-l2"><a class="reference internal" href="交付中的Version和Revision.html">交付中的Version和Revision</a></li>
<li class="toctree-l2"><a class="reference internal" href="约束选择.html">约束选择</a></li>
<li class="toctree-l2"><a class="reference internal" href="git-submodule的理解.html">git submodule的理解</a></li>
<li class="toctree-l2"><a class="reference internal" href="思维的串行化要求.html">思维的串行化要求</a></li>
<li class="toctree-l2"><a class="reference internal" href="什么是函数式编程.html">什么是函数式编程</a></li>
<li class="toctree-l2"><a class="reference internal" href="管理上的判断和技术上的判断.html">管理上的判断和技术上的判断</a></li>
<li class="toctree-l2"><a class="reference internal" href="基于逻辑链建立约束.html">基于逻辑链建立约束</a></li>
<li class="toctree-l2"><a class="reference internal" href="高级需求分析.html">高级需求分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="False_Sharing.html">假共享内存(False Sharing)</a></li>
<li class="toctree-l2"><a class="reference internal" href="芯片验证软件的4+1方法.html">芯片验证软件的4+1方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="软件之硬.html">软件之硬</a></li>
<li class="toctree-l2"><a class="reference internal" href="诚其意.html">诚其意</a></li>
<li class="toctree-l2"><a class="reference internal" href="把什么放入架构设计.html">把什么放入架构设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="线程的本质.html">线程的本质</a></li>
<li class="toctree-l2"><a class="reference internal" href="限制的可移动性.html">限制的可移动性</a></li>
<li class="toctree-l2"><a class="reference internal" href="指令寻址模式.html">指令寻址模式</a></li>
<li class="toctree-l2"><a class="reference internal" href="ARMv8的安全特性的主线逻辑.html">ARMv8的安全特性的主线逻辑</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Linux主线内核跟踪/README.html">Linux主线内核跟踪</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../README.html">MySummary</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../README.html">Docs</a> &raquo;</li>
        
          <li><a href="README.html">软件架构设计</a> &raquo;</li>
        
      <li>Makefile概念入门</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/软件构架设计/Makefile概念入门.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="makefile">
<h1>Makefile概念入门<a class="headerlink" href="#makefile" title="永久链接至标题">¶</a></h1>
<div class="section" id="id1">
<h2>版本<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>V0.1 Kenneth Lee 先写一个框架出来</p>
</div>
<div class="section" id="id2">
<h2>介绍<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>写这篇东西原始目的不是为了介绍怎么写Makefile，而是介绍怎么用“基于目标分层”的方
式理解一个工具，写作一个概念，定义一个设计或者部署一套代码。</p>
<p>但我介绍这种“方式”的方法是，写一个“Makefile的写作入门”。所以，本文首先是一个“
Makefile入门”，然后才是“基于目标分层的方法介绍”。</p>
<p>不少的Makefile的介绍材料总是上来就开始介绍“依赖”，“规则”，而默认你已经知道为什
么你需要“依赖”和“规则”了，很多“热爱学习”的工程师也把这些“依赖”和“规则”事无巨细
地记在心里，然后你看着他们学习了很久的Makefile，但一直都搞不清楚他学了些啥，写
的Makefile也就仿一下别家的模式，什么真的需要，什么不是真的需要，他们是搞不清楚
的。</p>
</div>
<div class="section" id="id3">
<h2>关于程序编译<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>Makefile解决的是编译的问题。编译有什么问题呢？比如说，你有3个C文件——等等，让我
们先偏个题，说明一下——Makefile最初是用来解决C语言的编译问题的，所以和C的关系特
别密切，但并不是说Makefile只能用来解决C的编译问题。你用来处理Java一点问题没有，
但对于Java，显然ant比Makefile处理得更好。但那是细节，你理解了Makefile，理解ant
就没有什么难度了。再说了，Makefile本身的格式也不是什么标准，不同的make工具对
Makefile本身怎么写细节是不一样的，本文介绍的是这个工具的思想原理，细节你要自己
看对应的手册。由于本文是在Linux上写的，所以我会用gnumake的格式作为例子，但从原
理上说，它们是非常相似的。</p>
<p>回到“有三个C文件”的问题。比如说，你有foo.c, bar.c, main.c三个C文件，你要编译成
一个app.executable，你会怎么做呢？你会执行这样的命令：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gcc</span> <span class="o">-</span><span class="n">Wall</span> <span class="o">-</span><span class="n">c</span> <span class="n">foo</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">foo</span><span class="o">.</span><span class="n">o</span>
<span class="n">gcc</span> <span class="o">-</span><span class="n">Wall</span> <span class="o">-</span><span class="n">c</span> <span class="n">bar</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">bar</span><span class="o">.</span><span class="n">o</span>
<span class="n">gcc</span> <span class="o">-</span><span class="n">Wall</span> <span class="o">-</span><span class="n">c</span> <span class="n">main</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">main</span><span class="o">.</span><span class="n">o</span>
<span class="n">gcc</span> <span class="n">main</span><span class="o">.</span><span class="n">o</span> <span class="n">foo</span><span class="o">.</span><span class="n">o</span> <span class="n">bar</span><span class="o">.</span><span class="n">o</span> <span class="o">-</span><span class="n">lpthread</span> <span class="o">-</span><span class="n">o</span> <span class="n">app</span><span class="o">.</span><span class="n">executable</span>
</pre></div>
</div>
<p>按Unix程序员的惯例（应该说，这是所有程序员的惯例），凡是要一次次重新执行的命令
，都应该写成脚本，变成“一个动作”。所以，简单来说，你会把上面这个命令序列写成一
个build.sh，每次编译你只要执行这个脚本问题就解决了。</p>
<p>但这个脚本有问题，假设我修改了foo.c，但我没有修改bar.c和main.c，那么执行这个脚
本是很浪费的，因为它会无条件也重新编译bar.c和main.c。</p>
<p>所以，这个脚本更合理的写法应该是这样的：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="n">foo</span><span class="o">.</span><span class="n">o</span> <span class="o">-</span><span class="n">ot</span> <span class="n">foo</span><span class="o">.</span><span class="n">c</span> <span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">gcc</span> <span class="o">-</span><span class="n">Wall</span> <span class="o">-</span><span class="n">c</span> <span class="n">foo</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">foo</span><span class="o">.</span><span class="n">o</span>
<span class="p">[</span> <span class="n">bar</span><span class="o">.</span><span class="n">o</span> <span class="o">-</span><span class="n">ot</span> <span class="n">bar</span><span class="o">.</span><span class="n">c</span> <span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">gcc</span> <span class="o">-</span><span class="n">Wall</span> <span class="o">-</span><span class="n">c</span> <span class="n">bar</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">bar</span><span class="o">.</span><span class="n">o</span>
<span class="p">[</span> <span class="n">main</span><span class="o">.</span><span class="n">o</span> <span class="o">-</span><span class="n">ot</span> <span class="n">main</span><span class="o">.</span><span class="n">o</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">gcc</span> <span class="o">-</span><span class="n">Wall</span> <span class="o">-</span><span class="n">c</span> <span class="n">main</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">main</span><span class="o">.</span><span class="n">o</span>
<span class="p">[</span> <span class="n">app</span><span class="o">.</span><span class="n">executable</span> <span class="o">-</span><span class="n">ot</span> <span class="n">main</span><span class="o">.</span><span class="n">o</span> <span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">[</span> <span class="n">app</span><span class="o">.</span><span class="n">executable</span> <span class="o">-</span><span class="n">ot</span> <span class="n">foo</span><span class="o">.</span><span class="n">o</span> <span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">[</span> <span class="n">app</span><span class="o">.</span><span class="n">executable</span> <span class="o">-</span><span class="n">ot</span> <span class="n">bar</span><span class="o">.</span><span class="n">o</span> <span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">gcc</span> <span class="n">main</span><span class="o">.</span><span class="n">o</span> <span class="n">foo</span><span class="o">.</span><span class="n">o</span> <span class="n">bar</span><span class="o">.</span><span class="n">o</span> <span class="o">-</span><span class="n">lpthread</span> <span class="o">-</span><span class="n">o</span> <span class="n">app</span><span class="o">.</span><span class="n">executable</span>
</pre></div>
</div>
<p>这很复杂是不是？同样按Unix程序员的一般作风，如果你面对一个问题，不要尝试重新去
定义这个问题，而是看它和原来的问题相比，多出来的问题是什么，尝试解决那个多出来
的问题就好了。</p>
<p>那么这里，多出来的问题就是文件修改时间比较。这个就是Makefile要解决的基本问题了
。我们定义一种新的“脚本语言”（只是不用sh/bash/tch来解释，而是用make来解释），可
以用很简单的方法来说明我们需要做的文件比较。这样上面的脚本就可以写成这个样子了
：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#sample1</span>
<span class="n">foo</span><span class="o">.</span><span class="n">o</span><span class="p">:</span> <span class="n">foo</span><span class="o">.</span><span class="n">c</span>
  <span class="n">gcc</span> <span class="o">-</span><span class="n">Wall</span> <span class="o">-</span><span class="n">c</span> <span class="n">foo</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">foo</span><span class="o">.</span><span class="n">o</span>
<span class="n">bar</span><span class="o">.</span><span class="n">o</span><span class="p">:</span> <span class="n">bar</span><span class="o">.</span><span class="n">c</span>
  <span class="n">gcc</span> <span class="o">-</span><span class="n">Wall</span> <span class="o">-</span><span class="n">c</span> <span class="n">bar</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">woo</span><span class="o">.</span><span class="n">o</span>
<span class="n">main</span><span class="o">.</span><span class="n">o</span><span class="p">:</span> <span class="n">main</span><span class="o">.</span><span class="n">c</span>
  <span class="n">gcc</span> <span class="o">-</span><span class="n">Wall</span> <span class="o">-</span><span class="n">c</span> <span class="n">main</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">main</span><span class="o">.</span><span class="n">o</span>
<span class="n">app</span><span class="o">.</span><span class="n">executable</span><span class="p">:</span> <span class="n">foo</span><span class="o">.</span><span class="n">o</span> <span class="n">bar</span><span class="o">.</span><span class="n">o</span> <span class="n">main</span><span class="o">.</span><span class="n">o</span>
  <span class="n">gcc</span> <span class="n">main</span><span class="o">.</span><span class="n">o</span> <span class="n">foo</span><span class="o">.</span><span class="n">o</span> <span class="n">bar</span><span class="o">.</span><span class="n">o</span> <span class="o">-</span><span class="n">lpthread</span> <span class="o">-</span><span class="n">o</span> <span class="n">app</span><span class="o">.</span><span class="n">executable</span>
</pre></div>
</div>
<p>这样读写起来是不是就简单多了？</p>
<p>这就是Makefile解决的原始问题。Makefile不是必须的，但它能减少你很多麻烦。有人可
能会说，为什么要这么麻烦？我们用IDE就好了。IDE封装了Makefile的使用当然好，问题
是IDE在里面都是用默认的规则（相当于有一个默认的Makefile），但如果你想具体控制特
定文件的编译细节，最终你还不是一样面对这些问题？ 所以，这个完全不是个IDE和make
工具的对比问题，这两者解决的是问题的不同层次。</p>
<p>上面那个Makefile中，foo.o: foo.c定义了一个“依赖”，说明foo.o是靠foo.c编译成的，
它后面缩进的那些命令，就是简单的shell脚本，称为规则(rule)。而Makefile的作用是定
义一组依赖，当被依赖的文件比依赖的文件新，就执行规则。这样，前面的问题就解决了
。</p>
<p>Makefile中的依赖定义构成了一个依赖链（树），比如上面这个Makefile中，
app.executable依赖于main.o，main.o又依赖于main.c，所以，当你去满足
app.executable（这个目标）的依赖的时候，它首先去检查main.o的依赖，直到找到依赖
树的叶子节点(main.c），然后进行时间比较。这个判断过程由make工具来完成，所以，和
一般的脚本不一样。Makefile的执行过程不是基于语句顺序的，而是基于依赖链的顺序的
。</p>
<blockquote>
<div><div class="figure">
<img alt="../_images/makefile依赖.png" src="../_images/makefile依赖.png" />
</div>
</div></blockquote>
</div>
<div class="section" id="phony">
<h2>phony依赖<a class="headerlink" href="#phony" title="永久链接至标题">¶</a></h2>
<p>make命令执行的时候，后面跟一个“目标”（不带参数的话默认是第一个依赖的目标），然
后以这个目标为根建立整个依赖树。依赖树的每个节点是一个文件，任何时候我们都可以
通过比较每个依赖文件和被依赖文件的时间，以决定是否需要执行“规则”。</p>
<p>但有时，我们希望某个规则“总是”被执行。这时，很自然地，我们会定义一下“永远都不会
被满足”的依赖。比如你可能会这样写：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">test</span><span class="p">:</span>
  <span class="n">DEBUG</span><span class="o">=</span><span class="mi">1</span> <span class="o">./</span><span class="n">app</span><span class="o">.</span><span class="n">executable</span>
</pre></div>
</div>
<p>test这个文件永远都不会被产生，所以，你只要执行这个依赖，rule是必然会被执行的。
这种形式看起来很好用，但由于make工具默认认为你这是个文件，当它成为依赖链的一部
分的时候，很容易造成各种误会和处理误差。</p>
<p>所以，简化起见，Makefile允许你显式地把一个依赖目标定义为“假的”（Phony）：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">.</span><span class="n">PHONY</span><span class="p">:</span> <span class="n">test</span>
<span class="n">test</span><span class="p">:</span>
 <span class="n">DEBUG</span><span class="o">=</span><span class="mi">1</span> <span class="o">./</span><span class="n">app</span><span class="o">.</span><span class="n">executable</span>
</pre></div>
</div>
<p>这样make工具就不用多想了，也不用检查test这个文件的时间了，反正test就是假的，如
果有人依赖它，无条件执行就对了。</p>
<p>PHONY目标算不上是Makefile的基础知识的一部分，我之所以提出来，是要用一个简单的例
子说明，“名称定义”是怎么影响“后续逻辑和新名称定义的”。所谓“为学日益”，就是这个
意思，你为了解决一个问题，就会定义一个新的逻辑（名称），这个然后这个新的名称，
就会制造新的问题，你解决那个问题，就需要新的名称定义，就会产生新的问题，就需要
更多的名字。日益增加的“名字”，最终会成为对你脑子的DoS攻击，导致“控制”的最终失控
。在这个例子中，因为我们引入了“目标和依赖”，所以我们才有了“假目标”这个定义，而
因为我们有了“假目标”这个定义，我们后面就会引入“假依赖”的问题。你在整个逻辑思考
的过程中，就不能不多考虑一个“名称要素”，这些是“成本”，要省着用。所以我们才有了“
不敢为主而为客”。“为客”就是让每个“名称”都要“买下至少一个问题”，不解决问题的“名
称”，就让它去死。</p>
<p>后面讨论的每个问题，我都隐含了这个逻辑，请读者从现在起就开始注意。</p>
</div>
<div class="section" id="id4">
<h2>宏<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>前面的sample1明显还是有很多多余的成份，这些多余的成份可以简单通过引入“宏”定义来
解决，比如上面的Makefile，我们把重复的东西都用宏来写，就成了这样了：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#sample2
CC=gcc -Wall -c
LD=gcc

foo.o: foo.c
 $(CC) foo.c -o foo.o
bar.o: bar.c
 $(CC) bar.c -o bar.o
main.o: main.c
 $(CC) main.c -o main.o
app.executable: foo.o woo.o main.o
 $(LD) main.o foo.o bar.o -o app.executable
</pre></div>
</div>
<p>这个写出来，还是有“多余”的成份在，因为明明依赖中已经写了foo.o了，rule中还要再写
一次，我们可以把依赖的对象定义为$&#64;，被依赖的对象定义为$^（这是当前gnumake的设计
），这样就可以进一步化简：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#sample3
CC=gcc -Wall -c
LD=gcc

foo.o: foo.c
  $(CC) $^ -o $@
bar.o: bar.c
  $(CC) $^ -o $@
main.o: main.c
  $(CC) $^ -o $@
app.executable: foo.o woo.o main.o
  $(LD) $^ -o $@
</pre></div>
</div>
<p>很明显，这还是有重复，我们可以把重复的定义写成通配符：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#sample4
CC=gcc -Wall -c
LD=gcc

%.o: %.c
 $(CC) $^ -o $@
foo.o: foo.c
woo.o: woo.c
main.o: main.c
app.executable: foo.o woo.o main.o
 $(LD) $^ -o $@
</pre></div>
</div>
<p>这终于短了吧。实际上，你要化简，还有很多手段，比如gnumake其实是默认定义了一组
rule的，上面这个整个你都可以不写，就这样就可以了：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#sample5
LDLIBS=-lpthead
SRC=$(wildcard *.c)
OBJ=$(SRC:.c=.o)
app.executable: $(OBJ)
</pre></div>
</div>
<p>这里其实没有定义.o到.c的依赖，但gnumake默认如果.c存在，.o就依赖对应的.c，而.o到
.c的rule，是通过宏默认定义的。你只要修改CC，LDLIBS这类的宏，就能解决大部分问题
了。所以你又省掉了一组定义，这就可以写得很短。</p>
<p>我前面的博文中说到，构架设计具有存在性的。这是一个例子，其实在我们开始定义最初
Makefile的语义的时候，最后软件会长成这个样子，已经是可预期的了。这就叫执古之道
，以御今之有。</p>
</div>
<div class="section" id="id5">
<h2>头文件问题<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>现在我们把问题搞得复杂一点，增加三个头文件。比如foo.h, bar.h和common.h，前两者
定义foo.c和bar.c的对外接口，给main.c使用，common.h定义所有文件都要用到的通用定
义（foo.h和woo.h中包含common.h)。这样前面这个sample1就有毛病了。照理说，foo.h更
新的时候，foo.o和main.o都需要重新编译，但根据那个定义，根本就没有这个比较。</p>
<p>为了增加这个比较，我们的定义必须写成这个样子：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#sample4+
CC=gcc -Wall -c
LD=gcc

%.o: %.c
  $(CC) $&lt; -o $@
foo.o: foo.c foo.h common.h
bar.o: bar.c bar.h common.h
main.o: main.c foo.h bar.h common.h
app.executable: foo.o bar.o main.o
  $(LD) $^ -o $@
</pre></div>
</div>
<p>(注：这个例子我们在.o.c依赖的规则中使用了$&lt;宏，它和$^的区别是，它不包括依赖列表
中的所有文件，而仅仅是列表中的第一个文件）</p>
<p>这就又增加了复杂度了——头文件包含关系一变化，我就得更新这个Makefile的定义。这带
来了升级时的冗余工作。按我们前面考虑一样的策略，我们尝试在已有的名称空间上解决
这个问题。Makefile已经可以定义依赖了，但我们不知道这个依赖本身。这个事情谁能解
决？——把这个过程想一下——其实已经有人解决这个问题了，这个包含关系谁知道嘛？当然
是编译器。编译器都已经用到那个头文件了，当然是它才知道这种包含关系是什么样的。
比如gcc本身直接就提供了-M系列参数，可以自动帮你生成依赖关系。比如你执行gcc -MM
foo.c就可以得到:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">foo</span><span class="o">.</span><span class="n">o</span><span class="p">:</span> <span class="n">foo</span><span class="o">.</span><span class="n">c</span> <span class="n">foo</span><span class="o">.</span><span class="n">h</span> <span class="n">common</span><span class="o">.</span><span class="n">h</span>
</pre></div>
</div>
<p>这样，剩下的问题是Makefile得先生成依赖本身，然后再基于依赖来生成文件。这样，我
们可以把Makefile写成这样（为了简单，我直接用sample5来改了）：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#sample5+
LDLIBS=-lpthead
CFLAGS+=-MMD -MP
SRC=$(wildcard *.c)
OBJ=$(SRC:.c=.o)
DEP=$(SRC:.c=.d)
-include $(DEP)
app.executable: $(OBJ)
</pre></div>
</div>
<p>CFLAGS中增加的参数可以为xxx.c产生xxx.d文件，里面就是那个依赖关系，然后我用
-include包含这些依赖关系。这样就不再需要手工来写每个依赖了。为了解决这个问题，
你已经看见了，include前面又增加了一个语法。那个减号表示允许被包含的文件不存在。</p>
<p>不仅如此，一旦引入这样的支持，我们就必须面对一个新的问题了：一开始foo.d不存在，
Makefile所定义的依赖链是一个样子，等foo.d存在了，它又是一个样子。那make工具以哪
个样子为准呢？</p>
<p>所以，这又引入了所谓的“remake rule”，决定了在什么时刻，make工具以什么为准。这个
rule的细节，读者可以自己找手册看。大概的原理是make会第一次先认出所有的用于组成
Makefile定义的文件，然后先make一次，等更新后，再做第二次的更新。名的复杂度，就
是这样一步步建立起来的。“无中生有”的过程，在计算机软件领域其实表现得最为淋漓尽
致。你说这个概念是本身就已经存在了，所以你定义出来了呢？还是因为你“发明”了它，
所以它就存在了呢？</p>
</div>
<div class="section" id="autoconf">
<h2>autoconf<a class="headerlink" href="#autoconf" title="永久链接至标题">¶</a></h2>
<p>然后我们接着处理下一个问题，因为我们有了Makefile，所以跨平台的问题就活该
Makefile来解决了。跨平台要面对的是不同平台习惯不同的问题。这种问题一个解决方案
是定义标准，比如POSIX。POSIX规定了，如果你要用malloc，你就应该包含stdlib.h。但
你以为你是标准就是老大？我的平台就不包含stdlib.h，我就要包含alloc.h，怎么着？</p>
<p>你的编译器叫gcc，我的平台编译器就叫laozizuida_compiler，怎么着？</p>
<p>所以我们一开始会在Makefile前面包含一个文件，来生成这些定义，比如这样：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ifdef</span> <span class="n">WINDOWS</span>
  <span class="n">include</span> <span class="n">windows_def</span><span class="o">.</span><span class="n">mk</span>
<span class="c1">#endif</span>
<span class="c1">#ifdef LINUX</span>
  <span class="n">include</span> <span class="n">linux_def</span><span class="o">.</span><span class="n">mk</span>
<span class="c1">#endif</span>
<span class="o">...</span>
</pre></div>
</div>
<p>这样弄得编译的人非常头疼。如果我们比较一下，这个问题和Makefile鸟关系没有，它是
个“自动化宏定义”的问题。autoconf，就是从这个角度解决这个问题的。它的工作是生成
一组脚本，自动检查要参与编译的目标平台的某些定义应该是怎么样的，这样编译的人就
不需要去做那么多复杂的定义了，运行一下自动编译脚本就好了。</p>
<p>所以，如果你拿到一份基于autoconf的源代码，它的编译方法是这样的：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">configure</span>
<span class="n">make</span>
</pre></div>
</div>
<p>那个./configure取代了你手工设置参数过程，通过自动检查帮你设置参数。</p>
<p>autoconf相当于一个知识库，负责帮助你生成./configure。大部分gnu或者非gnu的开源项
目都使用autoconf生成这个检查过程。如果你随便下载一个源代码，你会发现这个脚本写
得相当复杂。为了生成这个复杂的脚本，autoconf为了你提供了一个更简单的语法——其实
也不是什么简单语法了，它是通过m4这种宏语言，把你用宏写的脚本，变成这个configure
文件。</p>
<p>用来生成configure的源文件叫configure.ac。这个东西的语法估计你也很难学。一般情况
下，其实你也不用学。autoconf提供了一个工具，叫autoscan，它可以根据你的源代码，
自动帮你生成一个模板，比如，在我这个空的只有foo,bar,main的工程中，它生成的模板
就是这样的：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#                                               -*- Autoconf -*-</span>
<span class="c1"># Process this file with autoconf to produce a configure script.</span>

<span class="n">AC_PREREQ</span><span class="p">([</span><span class="mf">2.69</span><span class="p">])</span>
<span class="n">AC_INIT</span><span class="p">([</span><span class="n">FULL</span><span class="o">-</span><span class="n">PACKAGE</span><span class="o">-</span><span class="n">NAME</span><span class="p">],</span> <span class="p">[</span><span class="n">VERSION</span><span class="p">],</span> <span class="p">[</span><span class="n">BUG</span><span class="o">-</span><span class="n">REPORT</span><span class="o">-</span><span class="n">ADDRESS</span><span class="p">])</span>
<span class="n">AC_CONFIG_SRCDIR</span><span class="p">([</span><span class="n">bar</span><span class="o">.</span><span class="n">c</span><span class="p">])</span>
<span class="n">AC_CONFIG_HEADERS</span><span class="p">([</span><span class="n">config</span><span class="o">.</span><span class="n">h</span><span class="p">])</span>

<span class="c1"># Checks for programs.</span>
<span class="n">AC_PROG_CC</span>

<span class="c1"># Checks for libraries.</span>

<span class="c1"># Checks for header files.</span>

<span class="c1"># Checks for typedefs, structures, and compiler characteristics.</span>

<span class="c1"># Checks for library functions.</span>
<span class="n">AC_FUNC_MALLOC</span>
<span class="n">AC_CONFIG_FILES</span><span class="p">(</span><span class="n">Makefile</span><span class="p">)</span>
<span class="n">AC_OUTPUT</span>
</pre></div>
</div>
<p>这个语法都不怎么需要学，对着改就是了，前后的两段宏是用来生成configure的开头和结
尾的，不要动，中间就放一堆的检查，检查结果会生成一组Makefile可以用的宏定义。</p>
<p>其中AC_CONFIG_SRCDIR是用来确定脚本是不是放在正确的源代码目录中的，所以输入参数
是其中一个“肯定会有”的源程序即可。</p>
<p>AC_CONFIG_FILES用来定义进行宏转换的文件，脚本生成了一堆宏以后，会读入这里定义的
文件，然后把其中的宏都替换掉。比如这里的参数是Makefile，脚本会找目录中的
<a class="reference external" href="http://Makefile.in">http://Makefile.in</a>，然后把里面的宏替换掉，生成Makefile。剩下的事情会怎么样，猜
都猜到了。</p>
<p>剩下的就是中间那些检查函数了，比如AC_PROG_CC用来检查gcc的名字，AC_FUNC_MALLOC用
来检查malloc函数是否被支持，一般来说也不用学，因为autoscan会自动根据你的源代码
找出来的。</p>
<p>把这个模板保存为configure.ac文件，然后执行autoconf，就会生成configure脚本，这样
你就不用关心更多的跨平台的细节了。如果你修改过源代码，觉得自己调用了更多的库。
可以重新运行autoscan，把新的，你觉得有用的检查也补充进去就可以了。</p>
<p>把上面这个过程画成一副图，就是这个样子的：</p>
<blockquote>
<div><div class="figure">
<img alt="../_images/autoconf依赖.png" src="../_images/autoconf依赖.png" />
</div>
</div></blockquote>
<p>也许你已经注意到了，图中比我的描述多了http://config.h.in，这只是另一个类似
autoscan的helper工具，辅助你生成不同平台上不同库函数宏定义的，你自己运行一下
autoheader就明白了。</p>
<p>我们说了，configure.ac其实是基于autoconf预定义的宏写的一个脚本，所以，你在里面
直接写脚本一点问题没有，比如，我有时会这样插一段进去：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="n">AC_CHECK_LIB</span><span class="p">([</span><span class="n">ossp</span><span class="o">-</span><span class="n">uuid</span><span class="p">],</span> <span class="p">[</span><span class="n">uuid_create</span><span class="p">],</span> <span class="p">[</span><span class="n">OSSPUUIDLIB</span><span class="o">=</span><span class="s2">&quot;-lossp-uuid&quot;</span><span class="p">])</span>
<span class="k">if</span> <span class="n">test</span> <span class="s2">&quot;x$OSSPUUIDLIB&quot;</span> <span class="o">=</span> <span class="s2">&quot;x&quot;</span><span class="p">;</span> <span class="n">then</span>
        <span class="n">AC_CHECK_LIB</span><span class="p">([</span><span class="n">uuid</span><span class="p">],</span> <span class="p">[</span><span class="n">uuid_create</span><span class="p">],</span> <span class="p">[</span><span class="n">UUIDLIB</span><span class="o">=</span><span class="s2">&quot;-luuid&quot;</span><span class="p">])</span>
<span class="n">fi</span>
<span class="k">if</span> <span class="n">test</span> <span class="s2">&quot;x$OSSPUUIDLIB$UUIDLIB&quot;</span> <span class="o">=</span> <span class="s2">&quot;x&quot;</span><span class="p">;</span> <span class="n">then</span>
        <span class="n">AC_ERROR</span><span class="p">([</span><span class="n">No</span> <span class="n">uuid</span> <span class="n">library</span> <span class="n">available</span><span class="p">])</span>
<span class="n">fi</span>
<span class="n">LIBS</span><span class="o">=</span><span class="s2">&quot;$LIBS $UUIDLIB $OSSPUUIDLIB&quot;</span>
<span class="o">...</span>
</pre></div>
</div>
<p>AC_CHECK_LIB是autoconf的m4宏，它负责检查ossp-uuid这个库是否存在，如果它不存在，
我可以用uuid，如果两个都不存在，我就报错。我需要的仅仅是autoconf的检查功能，其
他东西要怎么弄，完全在我的掌控之下。</p>
<p>所以，这个用起来自由度其实是很高的，你会写脚本就可以了。autoconf只是个知识库，
提醒你要主要跨平台的时候有什么要考虑的。你要自己增加什么检查，那是你的事情。整
个脚本体系可以一步步完善的。要知道你的检查产生了哪些宏，运行一次configure，然后
检查一下config.log就可以了，你会看到类似这样的东西：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">## ----------------- ##</span>
<span class="c1">## Output variables. ##</span>
<span class="c1">## ----------------- ##</span>

<span class="n">ACLOCAL</span><span class="o">=</span><span class="s1">&#39;$</span><span class="si">{SHELL}</span><span class="s1"> /home/kenny/work/hisi-repo/kernel-dev/samples/wrapdrive/missing aclocal-1.15&#39;</span>
<span class="n">AMDEPBACKSLASH</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\&#39;</span>
<span class="n">AMDEP_FALSE</span><span class="o">=</span><span class="s1">&#39;#&#39;</span>
<span class="n">AMDEP_TRUE</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
<span class="n">AMTAR</span><span class="o">=</span><span class="s1">&#39;$${TAR-tar}&#39;</span>
<span class="n">AM_BACKSLASH</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\&#39;</span>
<span class="n">AM_DEFAULT_V</span><span class="o">=</span><span class="s1">&#39;$(AM_DEFAULT_VERBOSITY)&#39;</span>
<span class="n">AM_DEFAULT_VERBOSITY</span><span class="o">=</span><span class="s1">&#39;1&#39;</span>
<span class="n">AM_V</span><span class="o">=</span><span class="s1">&#39;$(V)&#39;</span>
<span class="n">AR</span><span class="o">=</span><span class="s1">&#39;ar&#39;</span>
<span class="n">AUTOCONF</span><span class="o">=</span><span class="s1">&#39;$</span><span class="si">{SHELL}</span><span class="s1"> /home/kenny/work/hisi-repo/kernel-dev/samples/wrapdrive/missing autoconf&#39;</span>
<span class="n">AUTOHEADER</span><span class="o">=</span><span class="s1">&#39;$</span><span class="si">{SHELL}</span><span class="s1"> /home/kenny/work/hisi-repo/kernel-dev/samples/wrapdrive/missing autoheader&#39;</span>
<span class="n">AUTOMAKE</span><span class="o">=</span><span class="s1">&#39;$</span><span class="si">{SHELL}</span><span class="s1"> /home/kenny/work/hisi-repo/kernel-dev/samples/wrapdrive/missing automake-1.15&#39;</span>
<span class="n">AWK</span><span class="o">=</span><span class="s1">&#39;gawk&#39;</span>
<span class="n">CC</span><span class="o">=</span><span class="s1">&#39;gcc&#39;</span>
<span class="n">CCDEPMODE</span><span class="o">=</span><span class="s1">&#39;depmode=gcc3&#39;</span>
<span class="n">CFLAGS</span><span class="o">=</span><span class="s1">&#39;-g -O2&#39;</span>
<span class="n">CPP</span><span class="o">=</span><span class="s1">&#39;gcc -E&#39;</span>
<span class="n">CPPFLAGS</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
<span class="n">CYGPATH_W</span><span class="o">=</span><span class="s1">&#39;echo&#39;</span>
<span class="n">DEFS</span><span class="o">=</span><span class="s1">&#39;-DHAVE_CONFIG_H&#39;</span>
<span class="n">DEPDIR</span><span class="o">=</span><span class="s1">&#39;.deps&#39;</span>
<span class="n">DLLTOOL</span><span class="o">=</span><span class="s1">&#39;false&#39;</span>
<span class="n">DSYMUTIL</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
<span class="n">DUMPBIN</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
<span class="n">ECHO_C</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
<span class="n">ECHO_N</span><span class="o">=</span><span class="s1">&#39;-n&#39;</span>
<span class="n">ECHO_T</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
<span class="n">EGREP</span><span class="o">=</span><span class="s1">&#39;/bin/grep -E&#39;</span>
<span class="n">EXEEXT</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
<span class="n">FGREP</span><span class="o">=</span><span class="s1">&#39;/bin/grep -F&#39;</span>
<span class="n">GREP</span><span class="o">=</span><span class="s1">&#39;/bin/grep&#39;</span>
<span class="n">INSTALL_DATA</span><span class="o">=</span><span class="s1">&#39;$</span><span class="si">{INSTALL}</span><span class="s1"> -m 644&#39;</span>
<span class="n">INSTALL_PROGRAM</span><span class="o">=</span><span class="s1">&#39;$</span><span class="si">{INSTALL}</span><span class="s1">&#39;</span>
<span class="n">INSTALL_SCRIPT</span><span class="o">=</span><span class="s1">&#39;$</span><span class="si">{INSTALL}</span><span class="s1">&#39;</span>
<span class="n">INSTALL_STRIP_PROGRAM</span><span class="o">=</span><span class="s1">&#39;$(install_sh) -c -s&#39;</span>
<span class="n">LD</span><span class="o">=</span><span class="s1">&#39;/usr/bin/ld -m elf_x86_64&#39;</span>
<span class="n">LDFLAGS</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
<span class="n">LIBOBJS</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
<span class="n">LIBS</span><span class="o">=</span><span class="s1">&#39;-luuid -lsysfs -lpthread &#39;</span>
<span class="n">LIBTOOL</span><span class="o">=</span><span class="s1">&#39;$(SHELL) $(top_builddir)/libtool&#39;</span>
<span class="n">LIPO</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
<span class="n">LN_S</span><span class="o">=</span><span class="s1">&#39;ln -s&#39;</span>
<span class="n">LTLIBOBJS</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
<span class="n">LT_SYS_LIBRARY_PATH</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
</pre></div>
</div>
<p>该怎么用，也不用我说了。</p>
<p>我经常说，“也不用我说了”。这也是一种架构师习惯：但凡只剩下工作量的事情，就不再
考虑，无论这个事情以后是我自己干还是让别人干。至少构架方面的工作是做完了。所谓
架构设计，就是设计到怎么演进也不会有什么大风浪了为止。（但什么程度才不会有大风
浪，取决于为你工作的工程师是什么水平和习惯）</p>
</div>
<div class="section" id="automake">
<h2>automake<a class="headerlink" href="#automake" title="永久链接至标题">¶</a></h2>
<p>有了autoconf，检查工作简单多了，但http://Makefile.in还是不好写。所以，我们又有
了automake，用来产生http://Makefile.in。</p>
<p>automake用http://Makefile.am作为输入，生成http://Makefile.in。它提供了一个非常
简单的语法，类似这样的：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lib_LTLIBRARIES</span><span class="o">=</span><span class="n">libfoo</span><span class="o">.</span><span class="n">la</span>
<span class="n">libwd_la_SOURCES</span><span class="o">=</span><span class="n">foo</span><span class="o">.</span><span class="n">c</span> <span class="n">bar</span><span class="o">.</span><span class="n">c</span> <span class="n">common</span><span class="o">.</span><span class="n">h</span> <span class="n">foo</span><span class="o">.</span><span class="n">h</span> <span class="n">bar</span><span class="o">.</span><span class="n">h</span>

<span class="n">bin_PROGRAMS</span><span class="o">=</span><span class="n">app</span>
<span class="n">app_SOURCES</span><span class="o">=</span><span class="n">main</span><span class="o">.</span><span class="n">c</span>
<span class="n">app_LDADD</span><span class="o">=.</span><span class="n">libs</span><span class="o">/</span><span class="n">libfoo</span><span class="o">.</span><span class="n">a</span>
</pre></div>
</div>
<p>这个很简单吧：你要编译一个二进制，就把名字赋给bin_PROGRAMS，然后描述它的源代码
是什么，剩下的事情全部交给automake。</p>
<p>automake依赖autoconf，所以对configure.ac的写法有一些额外的要求。我这里是介绍原
理，不是介绍细节，所以这个读者随便搜索一下就能找到大把材料，简单试用一下就知道
怎么弄了。</p>
<p>我这里更愿意讨论这样一个问题：语义其实就是这么一回事——你要简单，你就失去细节的
控制，你要深入控制，你就要面对复杂度。所以，很大程度上，我们进行抽象，都是在两
者之间取得平衡，并没有“完美”的方法。你脑子里想得特好的“美好生活”，到你亲自去体
验的时候，你又觉得非常Boring。你的意愿，和你的好恶，并不重合。</p>
<p>所以，我们进行抽象设计，本质上是判断什么是使用者“不在乎”的部分，把那部分帮他选
了。你的模块就产生对他的价值。所以，Unix这种插件、组合式的设计是有道理的。你什
么都帮用户做了，总有他不满意的部分，每个都可以成为他把你整体放弃的理由。而分离
的插件，则是一个个独立的“逻辑收缩”，你要收缩哪部分逻辑（不想管细节），就单独用
那一个“逻辑收缩”就好了。至于更大规模的收缩，我们可以通过小逻辑组合出来。好比这
个automake，如果你仅仅就是编译一个Unix上的应用程序，该有的都有了，但如果你要控
制一堆自动生成的代码，它就不够看了，但这不影响你放弃automake，继续使用autoconf
和makefile等的功能。</p>
<p>所以评论中有人问，为什么有cmake这么高级的工具，还需要学习Makefile。这就看你到底
要控制到什么层次了。</p>
</div>
<div class="section" id="id6">
<h2>关于架构的进一步讨论<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<p>Makefile相关的概念我介绍完了，我觉得大线条我描述完了，细节可以看工具手册本身，
但如果读者觉得在大线条上哪里有不理解的，请提问，我再补充。</p>
<p>现在回到我想讨论的构架设计的问题上。</p>
<p>写程序是个精细控制的过程，至少现在如此。我们大部分程序员习惯了c=a+b，e=c+d这样
一步步逻辑组合的过程。很容易忘掉，构架是个粗糙控制的过程，构架的说法常常只是“算
一下这个多边形的面积”这种类型的。这听起来好像是种“老板要求”，在程序员看来是“技
术白痴”的要求。而架构师和两者的区别在于，架构师需要满足老板（客户）的意欲，同时
保证它是可行的。</p>
<p>所以架构师的思路（注：架构师也可以是程序员，当他进行架构设计的时候，我们认为他
是架构师。我一直都在写代码，但我进行架构设计的时候，干的活和我写代码的时候干的
活是完全不同的）和程序的思路是很不同的。这就好像你画一副画，打架子的时候和你细
绘眼睛的时候是完全不同的。</p>
<p>架构师在打架子的时候，考量的是，一旦这个架子定义成这样了，我把钱洒到这个架子中
，它最后会长什么模样。</p>
<p>软件首先是个工程问题，构架只是解决它“有机会成型”的问题，但工程上，你能否在每个
阶段都让你的软件保持一定的“收益”，这才是它最后“能成型”的关键。而保持这种收益的
关键就在于每波投资，都能产生“收益”，我们抛开商业收益这么远的东西，首先要解决一
批人的问题吧。在我们介绍Makefile这套工具的过程中，我们看到了这种变化的过程：</p>
<p>一开始你仅仅解决“更简单地描述文件依赖”这个问题，然后你简化用户描述的过程，然后
你加入自动平台判断，然后你加入“最简化描述Unix文件生成方法”……这每一次扩展，都是
在迎合一波足够Solid的用户需要，然后才前进的。构架控制的整个过程，就好像冲浪，不
是你有多用力去滑水去让滑浪板前进。而是你必须准备好，迎接下一个浪尖，浮起来，然
后顺势滑下去的一个过程。</p>
<p>能让一个架构生存下去，是因为这样的需求压力，而不是“投资”，“投资”会导致你有钱，
有钱就会任性，任性就会把钱投资在没有需求backup的功能上，比如说，假设这个
automake拿到一个亿的投资，他们可以把这个功能做出花来，界面支持，用AI进行辅助脚
本生成，等等等等。但为此也就解决一个生成http://Makefile.in，能持续养活这些人吗
？</p>
</div>
<div class="section" id="id7">
<h2>总结<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<p>总的来说，我想说的是，</p>
<p>第一，架构设计是存在的。前提是你注意到它，如果你进行增量设计的时候，从来都是推
翻前面的概念空间来从新开始，当然注意不到它的存在</p>
<p>第二，架构设计的架子和架构维护的过程，是完全不同的两个思路。前者保证的是生存的
可能性，后者是积累每一波的能力，浇灌到架子中，让它长起来。</p>
<p>所以，控制架构的过程，不是控制软件如你所愿的过程，而是一个捕获“现实世界如何”的
一个过程。</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="ARM服务器进展小结.html" class="btn btn-neutral float-right" title="ARM服务器进展小结" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="架构的存在性.html" class="btn btn-neutral float-left" title="架构的存在性" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Kenneth Lee

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>