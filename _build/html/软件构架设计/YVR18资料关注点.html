

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>YVR18资料关注点 &mdash; MySummary 1.0 文档</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="理解关联" href="理解关联.html" />
    <link rel="prev" title="从香农熵谈设计文档写作" href="从香农熵谈设计文档写作.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../README.html" class="icon icon-home"> MySummary
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../道德经直译/README.html">《道德经》直译</a></li>
<li class="toctree-l1"><a class="reference internal" href="../花朵的温室/README.html">花朵的温室</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="README.html">软件架构设计</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="什么是软件架构.html">什么是软件架构</a></li>
<li class="toctree-l2"><a class="reference internal" href="大型软件架构设计.html">大型软件架构设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="架构师具体设计什么.html">架构师具体设计什么</a></li>
<li class="toctree-l2"><a class="reference internal" href="Use Case图有什么用？.html">Use Case图有什么用？</a></li>
<li class="toctree-l2"><a class="reference internal" href="使用软件的四种方法.html">使用软件的四种方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="从单元测试理解软件.html">从单元测试理解软件</a></li>
<li class="toctree-l2"><a class="reference internal" href="名可名.html">名可名</a></li>
<li class="toctree-l2"><a class="reference internal" href="小国寡民.html">小国寡民</a></li>
<li class="toctree-l2"><a class="reference internal" href="需求分析的中心思路.html">需求分析的中心思路</a></li>
<li class="toctree-l2"><a class="reference internal" href="关于自然语言编程的方向问题.html">关于自然语言编程的方向问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="反者道之动——欣赏架构设计的基本逻辑.html">反者道之动——欣赏架构设计的基本逻辑</a></li>
<li class="toctree-l2"><a class="reference internal" href="让代码变立体.html">让代码变立体</a></li>
<li class="toctree-l2"><a class="reference internal" href="生成优秀的架构.html">生成优秀的架构</a></li>
<li class="toctree-l2"><a class="reference internal" href="分支设计要领.html">分支设计要领</a></li>
<li class="toctree-l2"><a class="reference internal" href="怎样做项目管理.html">怎样做项目管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="谈谈子女教育问题.html">谈谈子女教育问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="两种基本的构架表述方法.html">两种基本的构架表述方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="弱者道之用——谈技术工作中的守弱问题.html">弱者道之用——谈技术工作中的守弱问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="在Linux下做性能分析.html">在Linux下做性能分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="架构设计的0层逻辑.html">架构设计的0层逻辑</a></li>
<li class="toctree-l2"><a class="reference internal" href="解耦设计.html">解耦设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="怎么做高层设计.html">怎么做高层设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="理解架构版本.html">理解架构版本</a></li>
<li class="toctree-l2"><a class="reference internal" href="PCIE总线的保序模型.html">PCIE总线的保序模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="做与不做都是战略.html">做与不做都是战略</a></li>
<li class="toctree-l2"><a class="reference internal" href="海洋战术式的软件设计方法.html">海洋战术式的软件设计方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="解耦和不解耦.html">解耦和不解耦</a></li>
<li class="toctree-l2"><a class="reference internal" href="再谈“守弱”.html">再谈“守弱”</a></li>
<li class="toctree-l2"><a class="reference internal" href="互斥算法设计.html">互斥算法设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="英文版本的“弱者道之用”.html">英文版本的“弱者道之用”</a></li>
<li class="toctree-l2"><a class="reference internal" href="什么是“守”.html">什么是“守”</a></li>
<li class="toctree-l2"><a class="reference internal" href="从用户功能开始构架系统框架.html">从用户功能开始构架系统框架</a></li>
<li class="toctree-l2"><a class="reference internal" href="Linux发行版的库软件包组织.html">Linux发行版的库软件包组织</a></li>
<li class="toctree-l2"><a class="reference internal" href="地址空间的故事.html">地址空间的故事</a></li>
<li class="toctree-l2"><a class="reference internal" href="工作和读书有什么不同.html">工作和读书有什么不同</a></li>
<li class="toctree-l2"><a class="reference internal" href="怎样快速调试Linux内核.html">怎样快速调试Linux内核</a></li>
<li class="toctree-l2"><a class="reference internal" href="架构设计中的“少了”和“多了”的问题.html">架构设计中的“少了”和“多了”的问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="Linux iommu和vfio概念空间解构.html">Linux iommu和vfio概念空间解构</a></li>
<li class="toctree-l2"><a class="reference internal" href="怎样做代码Review.html">怎样做代码Review</a></li>
<li class="toctree-l2"><a class="reference internal" href="怎样做客户访谈.html">怎样做客户访谈</a></li>
<li class="toctree-l2"><a class="reference internal" href="RancherOS架构分析.html">RancherOS架构分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="再谈什么是软件架构.html">再谈什么是软件架构</a></li>
<li class="toctree-l2"><a class="reference internal" href="大道曰守，当时曰行.html">大道曰守，当时曰行</a></li>
<li class="toctree-l2"><a class="reference internal" href="不为天下先.html">不为天下先</a></li>
<li class="toctree-l2"><a class="reference internal" href="关于AI的胡说八道.html">关于AI的胡说八道</a></li>
<li class="toctree-l2"><a class="reference internal" href="学习本质？.html">学习本质？</a></li>
<li class="toctree-l2"><a class="reference internal" href="“设计的流程”和“代码的流程”.html">“设计的流程”和“代码的流程”</a></li>
<li class="toctree-l2"><a class="reference internal" href="概要设计不是代码.html">概要设计不是代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="“病病”.html">“病病”</a></li>
<li class="toctree-l2"><a class="reference internal" href="关于架构师的爱恨情仇——《黑客帝国》世界观解读.html">关于架构师的爱恨情仇——《黑客帝国》世界观解读</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio-mdev逻辑空间分析.html">vfio-mdev逻辑空间分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="Linux Socket 0拷贝特性.html">Linux Socket 0拷贝特性</a></li>
<li class="toctree-l2"><a class="reference internal" href="用户态DMA的问题.html">用户态DMA的问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="Multiprocess Support for Linux IOMMU driver.html">Multiprocess Support for Linux IOMMU driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="Linux RAS特性分析.html">Linux RAS特性分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="写论文.html">写论文</a></li>
<li class="toctree-l2"><a class="reference internal" href="基于“语义”编程.html">基于“语义”编程</a></li>
<li class="toctree-l2"><a class="reference internal" href="从学习assert的用法开始理解如何写“专业的程序”.html">从学习assert的用法开始理解如何写“专业的程序”</a></li>
<li class="toctree-l2"><a class="reference internal" href="架构的存在性.html">架构的存在性</a></li>
<li class="toctree-l2"><a class="reference internal" href="Makefile概念入门.html">Makefile概念入门</a></li>
<li class="toctree-l2"><a class="reference internal" href="ARM服务器进展小结.html">ARM服务器进展小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="怎么做初步的需求分析.html">怎么做初步的需求分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="关于设计方案中的逻辑链问题.html">关于设计方案中的逻辑链问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="从逻辑链问题讨论怎么做高层设计.html">从逻辑链问题讨论怎么做高层设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="工程逻辑链.html">工程逻辑链</a></li>
<li class="toctree-l2"><a class="reference internal" href="为什么你会在你的数据中心中部署ARM服务器.html">为什么你会在你的数据中心中部署ARM服务器</a></li>
<li class="toctree-l2"><a class="reference internal" href="如何为libvirt设置虚拟主机.html">如何为libvirt设置虚拟主机</a></li>
<li class="toctree-l2"><a class="reference internal" href="给普通人解释Spectre和Meltdown安全漏洞.html">给普通人解释Spectre和Meltdown安全漏洞</a></li>
<li class="toctree-l2"><a class="reference internal" href="给程序员解释Spectre和Meltdown漏洞.html">给程序员解释Spectre和Meltdown漏洞</a></li>
<li class="toctree-l2"><a class="reference internal" href="Is retpoline really safe.html">Is retpoline really safe?</a></li>
<li class="toctree-l2"><a class="reference internal" href="逻辑链，道，学和架构工作的本质.html">逻辑链，道，学和架构工作的本质</a></li>
<li class="toctree-l2"><a class="reference internal" href="Serverless是什么——谈如何捕获一个特性的架构本质.html">Serverless是什么——谈如何捕获一个特性的架构本质</a></li>
<li class="toctree-l2"><a class="reference internal" href="道法自然.html">道法自然</a></li>
<li class="toctree-l2"><a class="reference internal" href="自然，守弱和Plan B.html">自然，守弱和Plan B</a></li>
<li class="toctree-l2"><a class="reference internal" href="守弱的内涵和外延.html">守弱的内涵和外延</a></li>
<li class="toctree-l2"><a class="reference internal" href="找到道法自然的“度”.html">找到道法自然的“度”</a></li>
<li class="toctree-l2"><a class="reference internal" href="Specification的写法问题.html">Specification的写法问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="小姐和丫鬟的故事.html">小姐和丫鬟的故事</a></li>
<li class="toctree-l2"><a class="reference internal" href="知不知.html">知不知</a></li>
<li class="toctree-l2"><a class="reference internal" href="PCIE总线的地址问题.html">PCIE总线的地址问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="气和深度学习.html">气和深度学习</a></li>
<li class="toctree-l2"><a class="reference internal" href="单元测试的效果问题.html">单元测试的效果问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="Requirement Analyzing vs. Voting.html">Requirement Analyzing vs. Voting</a></li>
<li class="toctree-l2"><a class="reference internal" href="抽离设计逻辑.html">抽离设计逻辑</a></li>
<li class="toctree-l2"><a class="reference internal" href="盗夸.html">盗夸</a></li>
<li class="toctree-l2"><a class="reference internal" href="抽象还是不抽象的问题.html">抽象还是不抽象的问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tegra TX2一瞥.html">Tegra TX2一瞥</a></li>
<li class="toctree-l2"><a class="reference internal" href="Progress and confusion of the IOMMU name space.html">Progress and confusion of the IOMMU name space</a></li>
<li class="toctree-l2"><a class="reference internal" href="一样还是不一样.html">一样还是不一样</a></li>
<li class="toctree-l2"><a class="reference internal" href="运营还是交付.html">运营还是交付</a></li>
<li class="toctree-l2"><a class="reference internal" href="科普一下GPL和开源软件.html">科普一下GPL和开源软件</a></li>
<li class="toctree-l2"><a class="reference internal" href="怎么确定道.html">怎么确定道</a></li>
<li class="toctree-l2"><a class="reference internal" href="回调还是直调.html">回调还是直调</a></li>
<li class="toctree-l2"><a class="reference internal" href="接口的封装层次问题.html">接口的封装层次问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="git的基本架构欣赏.html">git的基本架构欣赏</a></li>
<li class="toctree-l2"><a class="reference internal" href="让设计自生.html">让设计自生</a></li>
<li class="toctree-l2"><a class="reference internal" href="架构控制的从权问题.html">架构控制的从权问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="设计的需求问题.html">设计的需求问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="性能优化的目标问题.html">性能优化的目标问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="加速器和其他硬件的区别.html">加速器和其他硬件的区别</a></li>
<li class="toctree-l2"><a class="reference internal" href="君子与其练达不若朴鲁与其曲谨不若疏狂.html">君子与其练达不若朴鲁与其曲谨不若疏狂</a></li>
<li class="toctree-l2"><a class="reference internal" href="有无之道——一个新的软件架构定义.html">有无之道——一个新的软件架构定义</a></li>
<li class="toctree-l2"><a class="reference internal" href="什么是管理.html">什么是管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="从香农熵谈设计文档写作.html">从香农熵谈设计文档写作</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">YVR18资料关注点</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pacbti">PAC和BTI特性的目的</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hpc">HPC相关进展</a></li>
<li class="toctree-l3"><a class="reference internal" href="#treble">Treble</a></li>
<li class="toctree-l3"><a class="reference internal" href="#spdx">SPDX</a></li>
<li class="toctree-l3"><a class="reference internal" href="#linux">当前的Linux调度器设计</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id1">内核测试手段</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#kselftest">kselftest</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gcov">gcov</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kmemleakkasan">kmemleak和Kasan</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#autofdo-arm">AutoFDO&#64;ARM</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">其他</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="理解关联.html">理解关联</a></li>
<li class="toctree-l2"><a class="reference internal" href="如何撰写技术交底书.html">如何撰写技术交底书</a></li>
<li class="toctree-l2"><a class="reference internal" href="infiniband概念空间分析.html">infiniband概念空间分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="再谈什么是高层设计.html">再谈什么是高层设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="再谈“法自然”的设计思路.html">再谈“法自然”的设计思路</a></li>
<li class="toctree-l2"><a class="reference internal" href="设计规范.html">设计规范</a></li>
<li class="toctree-l2"><a class="reference internal" href="开源交付.html">开源交付</a></li>
<li class="toctree-l2"><a class="reference internal" href="道纪.html">道纪</a></li>
<li class="toctree-l2"><a class="reference internal" href="X86上的ARM Linux调试环境.html">X86上的ARM Linux调试环境</a></li>
<li class="toctree-l2"><a class="reference internal" href="IOMMU的现状和发展.html">IOMMU的现状和发展</a></li>
<li class="toctree-l2"><a class="reference internal" href="单元测试的强与弱问题.html">单元测试的强与弱问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="做事，做名，绩效主义，以及架构战略.html">做事，做名，绩效主义，以及架构战略</a></li>
<li class="toctree-l2"><a class="reference internal" href="没有规则的规则.html">没有规则的规则</a></li>
<li class="toctree-l2"><a class="reference internal" href="大成若缺.html">大成若缺</a></li>
<li class="toctree-l2"><a class="reference internal" href="非易失内存随想.html">非易失内存随想</a></li>
<li class="toctree-l2"><a class="reference internal" href="参考平台.html">参考平台</a></li>
<li class="toctree-l2"><a class="reference internal" href="一个例子：名的边界效应.html">一个例子：名的边界效应</a></li>
<li class="toctree-l2"><a class="reference internal" href="抽象问题的模型.html">抽象问题的模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="另一个例子：名的边界效应.html">另一个例子：名的边界效应</a></li>
<li class="toctree-l2"><a class="reference internal" href="Zircon架构简单分析1: Overview.html">Zircon架构简单分析1: Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="在qemu中模拟设备.html">在qemu中模拟设备</a></li>
<li class="toctree-l2"><a class="reference internal" href="国产操作系统问题.html">国产操作系统问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="软件飞线.html">软件飞线</a></li>
<li class="toctree-l2"><a class="reference internal" href="状态机方法.html">状态机方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="一些典型的架构设计错误.html">一些典型的架构设计错误</a></li>
<li class="toctree-l2"><a class="reference internal" href="从CPU和TPU的不同语言抽象看抽象原则.html">从CPU和TPU的不同语言抽象看抽象原则</a></li>
<li class="toctree-l2"><a class="reference internal" href="限制管理.html">限制管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="WarpDrive as a General Heterogeneous Platform.html">WarpDrive as a General Heterogeneous Platform</a></li>
<li class="toctree-l2"><a class="reference internal" href="Multiarch概念调查.html">Multiarch概念调查</a></li>
<li class="toctree-l2"><a class="reference internal" href="ARM NUC.html">ARM NUC</a></li>
<li class="toctree-l2"><a class="reference internal" href="UML有没有用.html">UML有没有用</a></li>
<li class="toctree-l2"><a class="reference internal" href="推演一个Buffer分配的语法设计.html">推演一个Buffer分配的语法设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="架构师和项目经理的基本职责问题.html">架构师和项目经理的基本职责问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="锁使用设计.html">锁使用设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="从内核终止用户态程序的IO访问.html">从内核终止用户态程序的IO访问</a></li>
<li class="toctree-l2"><a class="reference internal" href="epoll和select.html">epoll和select</a></li>
<li class="toctree-l2"><a class="reference internal" href="状态机退出方法.html">状态机退出方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="不为天下先2.html">不为天下先2</a></li>
<li class="toctree-l2"><a class="reference internal" href="设计逻辑和代码逻辑.html">设计逻辑和代码逻辑</a></li>
<li class="toctree-l2"><a class="reference internal" href="流水线深度.html">流水线深度</a></li>
<li class="toctree-l2"><a class="reference internal" href="谁是主线？.html">谁是主线？</a></li>
<li class="toctree-l2"><a class="reference internal" href="理解指令集.html">理解指令集</a></li>
<li class="toctree-l2"><a class="reference internal" href="给使用设备的进程发信号.html">给使用设备的进程发信号</a></li>
<li class="toctree-l2"><a class="reference internal" href="Linux设备异常复位逻辑分析.html">Linux设备异常复位逻辑分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="投资开源社区的基本逻辑.html">投资开源社区的基本逻辑</a></li>
<li class="toctree-l2"><a class="reference internal" href="一个Linux死锁信息分析.html">一个Linux死锁信息分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="如何说谎.html">如何说谎</a></li>
<li class="toctree-l2"><a class="reference internal" href="代码生成器.html">代码生成器</a></li>
<li class="toctree-l2"><a class="reference internal" href="弟子规：美国军方禁止在C语言程序中使用malloc.html">弟子规：美国军方禁止在C语言程序中使用malloc</a></li>
<li class="toctree-l2"><a class="reference internal" href="自下而上和自上而下的设计.html">自下而上和自上而下的设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="正面竞争.html">正面竞争</a></li>
<li class="toctree-l2"><a class="reference internal" href="不知为美.html">不知为美</a></li>
<li class="toctree-l2"><a class="reference internal" href="高层封装的设计战略.html">高层封装的设计战略</a></li>
<li class="toctree-l2"><a class="reference internal" href="产业生态的原理和作用.html">产业生态的原理和作用</a></li>
<li class="toctree-l2"><a class="reference internal" href="弯道问题.html">弯道问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="无名概念的深入探讨.html">无名概念的深入探讨</a></li>
<li class="toctree-l2"><a class="reference internal" href="解释On-Chip Debug和Off-Chip Debug.html">解释On-Chip Debug和Off-Chip Debug</a></li>
<li class="toctree-l2"><a class="reference internal" href="接口和名称空间辨识.html">接口和名称空间辨识</a></li>
<li class="toctree-l2"><a class="reference internal" href="RISCV WMO和TSO具体解决什么问题.html">RISCV WMO和TSO具体解决什么问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="利益链.html">利益链</a></li>
<li class="toctree-l2"><a class="reference internal" href="从C的for和Python的for聊起.html">从C的for和Python的for聊起</a></li>
<li class="toctree-l2"><a class="reference internal" href="安全建模问题讨论.html">安全建模问题讨论</a></li>
<li class="toctree-l2"><a class="reference internal" href="Accelerator vs. Co-processor.html">Accelerator vs. Co-processor</a></li>
<li class="toctree-l2"><a class="reference internal" href="一个逻辑空间控制的例子：uacce生命周期管理.html">一个逻辑空间控制的例子：uacce生命周期管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="软件构架设计的入题角度问题.html">软件构架设计的入题角度问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="接口分层的问题.html">接口分层的问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="对Cache Coherence的重理解.html">对Cache Coherence的重理解</a></li>
<li class="toctree-l2"><a class="reference internal" href="接口定义的工作模型.html">接口定义的工作模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="Linux_net和net-next分支的维护策略.html">Linux net和net-next分支的维护策略</a></li>
<li class="toctree-l2"><a class="reference internal" href="WarpDrive用户态方案重构建议.html">WarpDrive用户态方案重构建议</a></li>
<li class="toctree-l2"><a class="reference internal" href="主线逻辑.html">主线逻辑</a></li>
<li class="toctree-l2"><a class="reference internal" href="架构设计的粗与细问题.html">架构设计的粗与细问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="狂人日记读后感——名称空间囚笼.html">狂人日记读后感——名称空间囚笼</a></li>
<li class="toctree-l2"><a class="reference internal" href="写程序和写小说的区别.html">写程序和写小说的区别</a></li>
<li class="toctree-l2"><a class="reference internal" href="再谈《弟子规》问题.html">再谈《弟子规》问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="理解弱内存顺序模型.html">理解弱内存顺序模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="思维上的洞2.html">思维上的洞2</a></li>
<li class="toctree-l2"><a class="reference internal" href="后软件时代和技术沙盘陷阱.html">后软件时代和技术沙盘陷阱</a></li>
<li class="toctree-l2"><a class="reference internal" href="怎么做项目管理2.html">怎么做项目管理2</a></li>
<li class="toctree-l2"><a class="reference internal" href="语言的控制力问题.html">语言的控制力问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="分享我的Linux内核开发环境.html">分享我的Linux内核开发环境</a></li>
<li class="toctree-l2"><a class="reference internal" href="开发视图.html">开发视图</a></li>
<li class="toctree-l2"><a class="reference internal" href="概念视图.html">概念视图</a></li>
<li class="toctree-l2"><a class="reference internal" href="处理视图.html">处理视图</a></li>
<li class="toctree-l2"><a class="reference internal" href="语言控制力问题.html">语言控制力问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="新手设计文档典型错误.html">新手设计文档典型错误</a></li>
<li class="toctree-l2"><a class="reference internal" href="讨论：OpenCL2.0SVM有什么好？.html">讨论：OpenCL2.0SVM有什么好？</a></li>
<li class="toctree-l2"><a class="reference internal" href="设计逻辑的细致和严密问题.html">设计逻辑的细致和严密问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="逻辑的平面和立体问题.html">逻辑的平面和立体问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="自由和约束.html">自由和约束</a></li>
<li class="toctree-l2"><a class="reference internal" href="给非专业人士介绍架构设计工作.html">给非专业人士介绍架构设计工作</a></li>
<li class="toctree-l2"><a class="reference internal" href="AML工作原理快速调研.html">AML工作原理快速调研</a></li>
<li class="toctree-l2"><a class="reference internal" href="qemu_PCIe总线结构.html">qemu PCIe总线结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="ARM64_Linux_Kernel_5.7无法GDB调试问题.html">ARM64 Linux Kernel 5.7无法GDB调试问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="分层抽象.html">分层抽象</a></li>
<li class="toctree-l2"><a class="reference internal" href="见素抱朴：一个关于交付的例子.html">见素抱朴：一个关于交付的例子</a></li>
<li class="toctree-l2"><a class="reference internal" href="三个锦囊.html">三个锦囊</a></li>
<li class="toctree-l2"><a class="reference internal" href="多核MMU和ASID管理逻辑.html">多核MMU和ASID管理逻辑</a></li>
<li class="toctree-l2"><a class="reference internal" href="PMA和PA方案对比.html">PMA和PA方案对比</a></li>
<li class="toctree-l2"><a class="reference internal" href="真假架构设计.html">真假架构设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="怎样写标准提案.html">怎样写标准提案</a></li>
<li class="toctree-l2"><a class="reference internal" href="安全问题的本质.html">安全问题的本质</a></li>
<li class="toctree-l2"><a class="reference internal" href="名称内涵的发展.html">名称内涵的发展</a></li>
<li class="toctree-l2"><a class="reference internal" href="标准和设计的区别.html">标准和设计的区别</a></li>
<li class="toctree-l2"><a class="reference internal" href="cond_mutex模型.html">cond/mutex模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="一个例子：架构的重要性和从权.html">一个例子：架构的重要性和从权</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvdimm_AD模式的内核应用模型.html">nvdimm AD模式的内核应用模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="早期架构设计问题.html">早期架构设计问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="所谓内部设计.html">所谓内部设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="“知不知”如何影响决策的？.html">“知不知”如何影响决策的？</a></li>
<li class="toctree-l2"><a class="reference internal" href="“优秀架构设计”.html">“优秀架构设计”</a></li>
<li class="toctree-l2"><a class="reference internal" href="Linux_Kernel架构赏析.html">Linux Kernel架构赏析</a></li>
<li class="toctree-l2"><a class="reference internal" href="说说对协程的看法.html">说说对协程的看法</a></li>
<li class="toctree-l2"><a class="reference internal" href="架构设计和实施的对齐和同步问题.html">架构设计和实施的对齐和同步问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="一个关于4+1视图的案例：从概念视图开始.html">一个关于4+1视图的案例：从概念视图开始</a></li>
<li class="toctree-l2"><a class="reference internal" href="“硬件状态机”.html">“硬件状态机”</a></li>
<li class="toctree-l2"><a class="reference internal" href="设计的减熵原理.html">设计的减熵原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="binfmt概念空间建模.html">binfmt概念空间建模</a></li>
<li class="toctree-l2"><a class="reference internal" href="架构设计入门知识.html">架构设计入门知识</a></li>
<li class="toctree-l2"><a class="reference internal" href="架构设计的大忌：我没错.html">架构设计的大忌：我没错</a></li>
<li class="toctree-l2"><a class="reference internal" href="“解决方案”.html">“解决方案”</a></li>
<li class="toctree-l2"><a class="reference internal" href="讨论一下eBPF.html">讨论一下eBPF</a></li>
<li class="toctree-l2"><a class="reference internal" href="交付中的Version和Revision.html">交付中的Version和Revision</a></li>
<li class="toctree-l2"><a class="reference internal" href="约束选择.html">约束选择</a></li>
<li class="toctree-l2"><a class="reference internal" href="在概念空间选择方案.html">在概念空间选择方案</a></li>
<li class="toctree-l2"><a class="reference internal" href="git-submodule的理解.html">git submodule的理解</a></li>
<li class="toctree-l2"><a class="reference internal" href="思维的串行化要求.html">思维的串行化要求</a></li>
<li class="toctree-l2"><a class="reference internal" href="什么是函数式编程.html">什么是函数式编程</a></li>
<li class="toctree-l2"><a class="reference internal" href="管理上的判断和技术上的判断.html">管理上的判断和技术上的判断</a></li>
<li class="toctree-l2"><a class="reference internal" href="基于逻辑链建立约束.html">基于逻辑链建立约束</a></li>
<li class="toctree-l2"><a class="reference internal" href="高级需求分析.html">高级需求分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="False_Sharing.html">假共享内存(False Sharing)</a></li>
<li class="toctree-l2"><a class="reference internal" href="芯片验证软件的4+1方法.html">芯片验证软件的4+1方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="软件之硬.html">软件之硬</a></li>
<li class="toctree-l2"><a class="reference internal" href="诚其意.html">诚其意</a></li>
<li class="toctree-l2"><a class="reference internal" href="把什么放入架构设计.html">把什么放入架构设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="线程的本质.html">线程的本质</a></li>
<li class="toctree-l2"><a class="reference internal" href="限制的可移动性.html">限制的可移动性</a></li>
<li class="toctree-l2"><a class="reference internal" href="指令寻址模式.html">指令寻址模式</a></li>
<li class="toctree-l2"><a class="reference internal" href="ARMv8的安全特性的主线逻辑.html">ARMv8的安全特性的主线逻辑</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Linux主线内核跟踪/README.html">Linux主线内核跟踪</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../README.html">MySummary</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../README.html">Docs</a> &raquo;</li>
        
          <li><a href="README.html">软件架构设计</a> &raquo;</li>
        
      <li>YVR18资料关注点</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/软件构架设计/YVR18资料关注点.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <p>..KennethLee版权所有2018-2020</p>
<p>:Authors:KennethLee
:Version:1.0</p>
<div class="section" id="yvr18">
<h1>YVR18资料关注点<a class="headerlink" href="#yvr18" title="永久链接至标题">¶</a></h1>
<div class="section" id="pacbti">
<h2>PAC和BTI特性的目的<a class="headerlink" href="#pacbti" title="永久链接至标题">¶</a></h2>
<p>今年由于计划冲突没有参加LinaroConnect，假期把会议分享的材料都看了一遍，把有意
思的一些信息总结在这里。</p>
<p>资源在这里：YVR18Resources，部分是演讲视频，部分包括胶片，但也有很多是两者都没
有的，按我的经验，会议结束后还没有的，后面也补不回来，所以，基本上你这里能看到
的就是所有的材料了。</p>
<p>材料都有编号，格式是Nnn，其中N是第几天的会议，nn是序号，后面提到相关材料的时候
，用序号来表示。</p>
<p>（注：由于我和这个组织有利益相关，所以这里只从个人角度谈个人觉得有趣的技术，不
做评价，也和Linaro的运作策略无关。）</p>
<p>ARM在指令版本v8.3（这里都是指A系列）的时候开始引入PAC，到v8.5的时候引入了BTI。
分别是对数据和指令访问进行了更复杂的控制。我只深入看过PAC的Spec，大概的意思是可
以给页面（在PTE上）加上一个tag，然后当你访问这个地址的时候，如果所使用的指针（
64位系统的指针有一部分空间没有用）没有带有这个tag，就异常。</p>
<p>而BTI的作用从介绍上看是类似的，不过是作用于代码，如果你跳转到另一个地址，而你所
执行的指令的页面上给定一个标记c，跳转的目标指令如果不以btic开头，就异常。示例
代码如下：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>start:
blrx0
...
good://如果x0定位在这里，就是正常的
btic
...
bad://如果x0定位在这里，就会异常
movx0,#16
...
</pre></div>
</div>
<p>我最早看PAC的Spec的时候，第一反应是这东西是用来支持pkey_mprotect()的（要知道这
是什么，请参考manmprotect，它是mprotect的升级版本）。但从这次会议的介绍来看，
这两个特性首先考量的目标场景是保护ROP和JOP。</p>
<p>所谓ROP和JOP分别是ReturnOrientedProgramming和JumpOrientedProgramming，这是
两种攻击技术。我们平时用得最多的缓冲区攻击都是找到那些对入口参数判断不严谨的函
数，然后通过非法的输入参数，诱导这些函数越界访问堆栈中的数据，冲掉函数的返回值
，从而让程序执行到另一个地方，实现攻击（比如更改攻击程序的权限，在root权限代码
中创建一个Shell等），这就是ROP。而JOP是一种更广泛意义的ROP，由于很多程序（特别
是C++一类的面向对象程序），经常使用跳转表，如果越界访问可以攻击到跳转表，同样可
以控制整个执行流程。</p>
<p>我猜这两个特性最终都会依赖pkey_mprotect()来实现的，但理解这两个特性的最终目的，
也许能让我们更加清楚应该如何测试这两个特性是否发挥了作用。ARM在介绍中说使用PAC
和BTI后，可以大幅降低制造ROP和JOP的Gadget代码的代码量，这个地方是我没有看懂的，
也许当时会场上有特别的解释？否则难道是把ROP和JOP当做是编程语言设计方法了？但无
论如何，PAC和BTI都是保护的方法。所以，我猜这也许是节省了保护代码的代码量吧，以
后有机会再确认这个问题。</p>
<p>老实说，现在ASLR，KPTI，pkey_mprotech这些技术盛行，以后调试会变得越来越困难。而
且，从架构的角度说，安全设计一定会让系统级调试会变得非常复杂，这次演讲102中提到
的RAS的报告流程，从硬件报到安全EL3，然后进非安全UEFI，然后又到安全EL0，准备完数
据又进非安全EL2和EL1，最后回到EL0的rasdaemon，这个在真实硬件上麻烦得一逼。</p>
<p>所以，我有个感觉，未来的调试会越来越聚焦到虚拟机这一层。演讲118提到qemu的TCG调
试功能（这个功能不叫这个名字，只是是在这个特性中做的）就是一种很好的体现。我大
概提炼一下这个功能是怎么用的[注1]：</p>
<p>qemuTCG功能可以用于qemu-user和qemu-system，我个人很少用user，我用system为例。
当你启动qemu后，可以通过^ac切换到qemu的虚拟机控制台，然后你可以用如下命令来查
你可以跟踪的事件：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">infotrace</span><span class="o">-</span><span class="n">events</span>
</pre></div>
</div>
<p>这个命令可以带参数对结果进行过滤：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">infotrace</span><span class="o">-</span><span class="n">eventsgicv3_</span><span class="o">*</span>
</pre></div>
</div>
<p>确定你要跟踪的事件后，用trace-event来跟踪对应事件，用trace-file设置跟踪文件（也
可以直接通过命令行参数-trace指定）：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">trace</span><span class="o">-</span><span class="n">eventsgicv3_</span><span class="o">*</span><span class="n">on</span>
<span class="n">trace</span><span class="o">-</span><span class="n">filesetmytrace</span><span class="o">.</span><span class="n">out</span>
</pre></div>
</div>
<p>qemu不是时钟精确的模拟器，暂时来说我还找不到非要用这个东西调试的场景，不过我对
这个东西的未来还是抱很高的期望。</p>
<p>注1：很多平台的qemu都没有开启trace功能，可以考虑自己编译一个，使用如下configure
选项：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">--</span><span class="n">enable</span><span class="o">-</span><span class="n">trace</span><span class="o">-</span><span class="n">backends</span><span class="o">=</span><span class="n">ftrace</span><span class="o">|</span><span class="n">log</span><span class="o">|</span><span class="n">dtrace</span><span class="o">|</span><span class="n">syslog</span>
</pre></div>
</div>
<p>推荐选择log，这个比较容易实验。我简单试用了一下相关功能，Bug不少，功能的自恰性
也比较差，暂时离实用还有距离。有人可能觉得这个东西用Foundation或者FPGAEmulator
就可以代替了，但这两个东西的效率和价钱……对吧？</p>
</div>
<div class="section" id="hpc">
<h2>HPC相关进展<a class="headerlink" href="#hpc" title="永久链接至标题">¶</a></h2>
<p>Linaro的HPC实验室筹划了有相当长的时间了，这次第一次看到有实物介绍出来（116）。
网络上包含两个1G的子网，用于外部接入（uplink）和BMC访问（bmc），以及两个100G子
网，用于Lustre文件系统（fs）和InfiniBand（mpi）。</p>
<p>软件栈使用CentOS（未来可以扩展到OpenSuse），Warewulf（集群管理）和Slurm（
Workload管理）。</p>
<p>投入的客户硬件包括华为和高通的服务器，InfiniBand都使用Mellanox的ConnectX上的板
卡（而不是SoC上自带的RoCE功能），软件使用OFED。</p>
<p>文件系统使用Lustre，据说过程比较痛苦，因为Mellanox的部分驱动不是开源的，每个有
这种商业公司介入的领域，都只能一个个单独合作，不太适合作为合作的中心。RoCE如此
，GPU也是如此。OPTEE其实也是一样的，给我的感觉，这个东西用于实用，不如说定义了
一个非安全软件（比如Linux）和安全软件之间进行通讯的接口定义。</p>
<p>203介绍了一下LLVM的进展，聚焦在指令调度上，不做编译器的估计不会太关心。</p>
<p>todo：其他的待补</p>
</div>
<div class="section" id="treble">
<h2>Treble<a class="headerlink" href="#treble" title="永久链接至标题">¶</a></h2>
<p>Treble方案在Linaro推了3年，从一开始谁都说不清楚是什么，现在再看，看起来比较成熟
了，虽然我自己不做手机方案了，但现在有人想到要“在服务器领域也可以学习Treble的优
秀实践”，所以我也来总结一下Treble方案的核心在什么地方。</p>
<p>Treble现在比较完整的叙述在这里：</p>
<p><a class="reference external" href="https://source.android.com/devices/architecture/">https://source.android.com/devices/architecture/</a></p>
<p><a class="reference external" href="https://source.android.com/devices/architecture/images/VNDK.pdf">https://source.android.com/devices/architecture/images/VNDK.pdf</a></p>
<p>它的目标现在也比较清楚了，是要把Framework部分完全独立出来，让升级Framework不需
要跟着下面Vendor相关的部分相对独立。</p>
<p>Treble提供了类似以前CTS兼容性测试套件类似的VTS前向兼容测试套件对兼容性进行测试
。</p>
<p>Treble兼容性通过升级的HAL层实现，为此引入了一种HIDL语言来描述两者之间的关系，定
义了两种HAL：</p>
<p>1.绑定式：主要用于流量不大的接口，基于Binder进行通讯</p>
<p>2.直通式：主要用于流量大的接口，基于传统的调用进行通讯，有可能是在同一个进程内
(SP-HAL），也可以通过共享内存来实现（比如传统的HWComposer）</p>
<p>HIDL本质上是对Binder接口的封装，源文件用hal做扩展名，很类似过去Binder的Java接口
定义文件，像这样：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">interfaceIBarextendsIFoo</span><span class="p">{</span><span class="o">//</span><span class="n">IFooisanotherinterface</span>
<span class="o">//</span><span class="n">embeddedtypes</span>
<span class="n">structMyStruct</span><span class="p">{</span><span class="o">/*...*/</span><span class="p">};</span>

<span class="o">//</span><span class="n">interfacemethods</span>
<span class="n">create</span><span class="p">(</span><span class="n">int32_tid</span><span class="p">)</span><span class="n">generates</span><span class="p">(</span><span class="n">MyStructs</span><span class="p">);</span>
<span class="n">close</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<p>如果是绑定式或者共享内存式，Framework和HAL间就是IPC调用，如果是SP-HAL方式，就变
成dlopen，然后直接进行相关的本地调用。</p>
<p>拿个现场的图来看更简单：</p>
<blockquote>
<div>..figure::treble.jpg</div></blockquote>
<p>在内核上，Treble推出了一个公共的主线：
<a class="reference external" href="https://android.googlesource.com/kernel/common/">https://android.googlesource.com/kernel/common/</a>，但从介绍材料上看是推荐性质的，
还没有能力让各家都使用同一个内核，这应该是一个合作效率的问题。Google在Linaro上
的项目是要拉着几个主要的供应商一起维护这个内核，但以AOSP现在的升级速度，我觉得
真正实现这个会比较困难。</p>
<blockquote>
<div>..figure::treble2.jpg</div></blockquote>
<p>Treble要求各家必须使用ko的方式提供驱动，然后尝试把通用内核和驱动放在vboot分区上
，Soc相关驱动放SoC分区上，ODM的相关驱动放在ODM分区上。希望可以独立升级通用内核
部分，我个人不是很看好这种模式。我认为他们升不了几个版本的。</p>
<p>从星期五的KeyNotes上看到，Google对于统一内核的主要考量是质量，他们认为没有持续
维护，代码的安全令人担心。但他们也承认这个问题在于，SoC的生命周期太短，这是影响
厂商投入到代码主线化的动力。AndroidCommon版本的质量保证用例主要来自两方面：LTP
和VTS（VendorTestSuit，通过sysfs激活Android相关功能）。</p>
<p>我个人不太认可这种实践可以用于服务器的。所谓接口稳定，前提就是接口没有改进需求
了。是改进期望影响了接口的稳定性，而不是接口稳定性的需求决定了如何改进。在PC领
域，很早就实现前向兼容了，而在几乎一样软件栈的服务器领域，到现在都没有完全实现
前向兼容。是因为在现在这个阶段，服务器还在拼性能，所以很多东西都还在修改，这种
情况下主动去把接口稳定下来，这是自己找死。</p>
<p>Treble花了三年成了现在的样子，有一个很重要的要素是这两年AOSP已经玩不出什么花样
了，你一个接口随你玩一两年都是一个样子，收缩起来是有意义的，但如果你不是，那就
是自己束缚自己了。</p>
<p>对了，演讲207中提到Treble把SELinux作为基础的安全保护错误，避免system和vendor的
代码可以访问其他分区。这个有空到是可以看看具体是怎么设计的。</p>
</div>
<div class="section" id="spdx">
<h2>SPDX<a class="headerlink" href="#spdx" title="永久链接至标题">¶</a></h2>
<p>最近上传LinuxKernel的代码的时候，都是拷贝别人的版权声明头，比如这样：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SPDX</span><span class="o">-</span><span class="n">License</span><span class="o">-</span><span class="n">Identifier</span><span class="p">:</span><span class="n">GPL</span><span class="o">-</span><span class="mf">2.0</span><span class="o">+</span>
</pre></div>
</div>
<p>一直没有认真去看看为什么现在都这样写声明了。209演讲里面，LinuxFoundation有人来
讲了相关的背景，这都源自这个项目：SoftwarePackageDataExchange(SPDX)</p>
<p>它定义了被广泛使用的常见版权的“标识”，建议通过这些标识来唯一定义一个版权声明。
所以现在Linux内核中都统一使用上面那样的声明方式。</p>
<p>实际上，根据最新定义的2.0版本，上面那个定义应该写成：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SPDX</span><span class="o">-</span><span class="n">License</span><span class="o">-</span><span class="n">Identifier</span><span class="p">:</span><span class="n">GPL</span><span class="o">-</span><span class="mf">2.0</span><span class="o">-</span><span class="ow">or</span><span class="o">-</span><span class="n">later</span>
</pre></div>
</div>
<p>GPL-2.0+已经被废弃了。</p>
<p>源代码中包含这样的声明，编译工具有就有机会找到对应的声明，生成内置在二进制中的
版权声明段，或者直接在输出中包含一个版权声明文件。</p>
<p>所以，以后写开源代码，不妨查一些这个列表：</p>
<blockquote>
<div>SoftwarePackageDataExchange(SPDX)spdx.org</div></blockquote>
<p>然后直接在源文件的最前面加上这个声明。更详细的表述方法，可以参考演讲221中的L4Re
的声明方法：</p>
<blockquote>
<div>kernkonzept/l4re-core</div></blockquote>
</div>
<div class="section" id="linux">
<h2>当前的Linux调度器设计<a class="headerlink" href="#linux" title="永久链接至标题">¶</a></h2>
<p>演讲220对Linux当前的调度器做了一个科普，感觉不深不浅的，不知道对大部分读者是否
具有参考价值。我对来说，已经很久没有看Linux的调度器了，很多原来没有很明确的概念
，经过这些年的发展，现在变得非常清晰，所以参考价值还是挺大的。我就着这个演讲描
述的概念，以及我自己掌握的一些东西，为这里的读者普及一些Linux调度器的初步知识，
也算是我自己对这部分信息的一个总结吧。</p>
<p>我们先来理解一下调度器面对的问题。我不知道没有写过调度器的读者是否会和我一样，
在我自己做操作系统设计之前，比如在学校学习操作系统原理的时候，我对调度器的认识
，有一个很大的误区，似乎调度器是“决定把哪个进程投入运行”的一个算法，但实际上，
它是“决定把哪个要运行的进程投入运行”的一个算法。这句话听起来一样，其实是不一样
的，后者意味着，在每个调度“时刻”，你只需要管要运行的进程，不用管其他进程。我们
很容易从一个时间广度上考虑这个问题，觉得调度器需要考虑所有的进程的状态，实际上
调度器只考虑现在就可以运行的进程的状态，算法只需要考虑在调度序列中的进程，其他
进程，都是不管的。这个现在单独跟你说，你会觉得“这谁不知道啊”，但等你看算法的时
候，你可能就晕菜了。我们先把这个前提放在这里，以便读者后面更容易理解概念。</p>
<p>其实也正因为这个理解不同，我们更多人能接受“CPU占用率”这个概念，而不是Load这个概
念，CPU占用率是时间广度的，是人的概念，而Load是一个时刻深度的，是调度器的概念。
人关心的是某段时间内，CPU的利用率有多高，一个时刻是没有CPU占用率这个概念的。而
调度器关心的是现在还有多少了进程等着被我调度，我让谁先上来，所以，这些被等着调
度的进程，就是我的Load。</p>
<p>理解CPU占用率和Load的分别，我们就会发现，调度器其实比我们想象中简单，因为调度器
是不考虑你的历史的，调度器考虑的是你这个进程加入到我的调度中后，我把你排在第几
位执行，如果你休眠了，你的历史就被清除了，我才不在乎你过去用了多少CPU呢（其实不
完全是这样，但我们先这样理解）。</p>
<p>有了这些基础，我们现在来理解一下调度器面对的问题。首先，我们有一些任务是很重要
的，如果它要运行，就必须让它先运行。这我们称为实时任务。实时任务是最容易处理的
。我刚入行的时候，一位做UnixOS的前辈就跟我说，RT调度器那就是玩具，基本上就让它
先执行就好了。同是RT进程的话，也只有RoundRobin和FIFO两种算法，如何工作你猜都能
猜到，最多就是补充一些优先级反转之类的保护，基本上没有什么值得发展的。这部分的
算法，本文也会忽略。</p>
<p>难的是普通的任务怎么调度。一个简单的思路，根据任务的优先级（nice），每个任务给
定一个调度时间片，然后每个任务用完自己的时间片，就等着，等到所有的任务都用完自
己的时间片了，就重新开始。</p>
<p>但你真的按这样的方法来试试，你就会发现，你这个系统基本上不可用。为什么呢？因为
任务有两种，一种是iobound，一种是cpubound的。iobound的任务处理io，cpubound
的是长时间执行，只是在消耗CPU。如果你平等地对待他们，每个任务执行50ms，10个cpu
bound的任务，1个shell，然后你在shell上按下一个a，这个a要等500ms才能回显出来，这
玩意儿没法用。要保证iobound的进程在前面，否则这东西没法用。这是大部分普通调度
器要解决的问题。</p>
<p>Linux在O(1)之前的调度器基本上是个玩具，那个东西我们就忽略了。我们先看O(1)调度器
的原理。从名字就能看出来，O(1)算法是要保证取下一个运行任务的时候，算法复杂度是
O(1)，它用这样的数据结构：</p>
<blockquote>
<div></div></blockquote>
<p>待运行的任务都挂在Active队列下面，每个Active分优先级Hash开，在用一个bitmap标记
哪个队列中有任务，这样，要投入运行，只要检查一下bitmap，然后拿那个队列的第一个
任务运行就可以了（这就是这个算法称为O(1)的原因）。当一个任务的时间片用完了，就
改挂到Expired队列。等Active队列空了，就把两者换过来，问题就递归了。</p>
<p>这个算法最大的破绽你也看到了，它区分不了谁是iobound进程。所以O(1)算法有一个非
常不好看的补充算法，主要是根据每个任务是否能用完自己的时间片就离开调度队列，如
果是这样，调度器就“补偿”它，提高它的Effective优先级，这样，它回来的时候，就可以
比较早得到调度了。我以前玩得比较多的就是这个算法，这个东西经常错判，而且很难调
试。后来，它就逐步被CFS取代了。</p>
<p>CFS在2.6.23开始引入内核，在2.6.30彻底取代了O(1)算法。它引入的变化首先是用
sched_class把不同的调度算法彻底分开了。正如演讲220中提到的，现在调度分了两层，
先按调度类别分类，优先调度高优先级类别的任务。这样，我们做普通调度的时候，就不
再需要考虑比如实时任务这样的任务了。</p>
<p>比如现在的内核中就包含了这些类别：</p>
<p>STOP：系统任务，比如RCU，ftrace，核间迁移。这些任务凌驾于所有其他任务有限调度</p>
<p>DL：DeadLine任务，这些任务有“必须什么时候完成”这样的诉求，所以在所有客户任务中
优先调度</p>
<p>RT：就是过去的实时任务了</p>
<p>CFS：这才是普通的任务调度</p>
<p>IDLE：这是IDLE任务swapper/N</p>
<p>这一层的原理非常直白了。</p>
<p>然后，我们仍单独理解CFS。完全公平调度。首先我们理解一下什么是“完美的公平调度”，
比如说，你有4个任务a,b,c,d，分别要运行4,4,8,12毫秒，CPU的时间片单位是4ms。</p>
<p>那么前四个4ms，应该是a,b,c,d每个周期各运行1ms，第五、六个4ms，a，b不在了，c
，d应该每个周期各运行2ms，这样，c也运行完了，剩下的d，再运行第七个4ms，把4ms全
部用完。这样就是完美的完全公平。</p>
<p>但我们做不到，因为我们不能无时无刻去比这些时间。所以，CFS就是一种“尽量公平调度
的方法”，每次到了一个调度点（比如时钟中断），它马上算一下现在的任务花了多少时间
，把这个时间加到它的vruntime中，之后调度的时候，总是取一个vruntime最短的任务来
执行。</p>
<p>这样，天然地，运行得最少，经常休眠的任务的优先级就会变高，总是优先得到调度了。</p>
<p>这个算法纯从计算上逼近iobound进程优先执行。比O(1)算法可控多了。</p>
<p>但它的破绽也是很明显的，如果你要装你是个iobound进程，你只要避开vruntime的计算点
，每次休眠一点点时间，就能保持你的优先级。</p>
<p>所以，实际上CFS还有很多补充算法来解决很多具体的问题，但无论如何，这个模型还是比
O(1)可控。</p>
<p>其实吧，也没有保证能公平的调度算法，这最后基本上就是调整出来的。也许等待AI的影
响力足够强，这东西应该是通过神经网络自动训练出来的？</p>
</div>
<div class="section" id="id1">
<h2>内核测试手段<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>演讲224和301介绍了在kselftest中增加ftracetest用例，还介绍了在内核中做GCOV的方法
。这让我想起要把Documents/dev-tools目录看一遍，就着写这个总结，我把相关的逻辑理
一下。</p>
<p>Linux内核进展越来越快，越来越成熟。现在上传一个特性到内核中要经过的测试越来越多
了。过去我们一般会做checkpatch，内部review，然后进行功能，LTP测试，就可以开始上
传了。</p>
<p>几年不看，其实现在已经不止有这些方法了，我们分两个维度来看：</p>
<p>静态检查的，除了checkpatch，我们还可以用sparse。用法如下（在安装了sparse的前提
下）：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">C</span><span class="o">=</span><span class="mi">1</span>
</pre></div>
</div>
<p>这会增加更严格的惯例检查。检查是附属在普通编译过程中的，如果你已经编译了所有.o
了，这个检查不会发生。</p>
<p>还有一个更强大的是胭脂虫(coccinelle)，用法如下（在安装了coccinelle以后，注1）：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">coccicheck</span>
</pre></div>
</div>
<p>这个命令可以缩小到某个目录的范围内，比如：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">makecoccicheckM</span><span class="o">=</span><span class="n">my</span><span class="o">/</span><span class="n">own</span><span class="o">/</span><span class="n">directory</span>
</pre></div>
</div>
<p>我试了一下，这个检查的功能还是很强大的，比如我的代码中有这么一行：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span><span class="o">-&gt;</span><span class="n">svas</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="o">=</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="o">-</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="n">PAGE_SHIFT</span>
</pre></div>
</div>
<p>它还能报这种错：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">WARNING</span><span class="p">:</span> <span class="n">Consider</span> <span class="n">using</span> <span class="n">vma_page</span> <span class="n">shelperonvma</span>
</pre></div>
</div>
<p>这个可以作为上传前标准检查的一部分。</p>
<p>动态检查的，我们有如下工具可以用：</p>
<div class="section" id="kselftest">
<h3>kselftest<a class="headerlink" href="#kselftest" title="永久链接至标题">¶</a></h3>
<p>这个类似LTP，是内置的一组功能测试用例，这样编译和运行：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span><span class="o">-</span><span class="n">Ctools</span><span class="o">/</span><span class="n">testing</span><span class="o">/</span><span class="n">selftest</span>
<span class="n">makekselftest</span>
</pre></div>
</div>
<p>其实编译出来的就是一个个独立的可执行程序，拷贝过去直接运行就可以了。</p>
<p>三星开源group在星期四的Keynote里介绍了这个东西的测试策略，要了解细节的可以听一
下。我看了一下代码，这个基本上是个很自由的测试用例，框架本身仅仅是提供错误计数
一类的东西，其他是你爱怎么写就怎么写。</p>
</div>
<div class="section" id="gcov">
<h3>gcov<a class="headerlink" href="#gcov" title="永久链接至标题">¶</a></h3>
<p>这是把gcov的功能用到内核上。在用户态做单元测试一般会用gcov和lcov检查覆盖率的，
这个功能现在在内核中也可以用了。它通过配置项CONFIG_GCOV_KERNEL使能。开启后，可
以在/sys/kernel/debugfs/gcov找到所有跟踪数据文件（.gcda)，用gcov命令就可以直接
看到代码的执行覆盖率。</p>
</div>
<div class="section" id="kmemleakkasan">
<h3>kmemleak和Kasan<a class="headerlink" href="#kmemleakkasan" title="永久链接至标题">¶</a></h3>
<p>这两个是自动内存检查，前者发现内存泄漏，后者发现use-after-free错误，分别通过
CONFIG_DEBUG_KMEMLEAK和CONFIG_KASAN使能，发现有问题会自动抱错的，可以作为基本CI
系统的一部分来用。</p>
<p>还有一个Kcov，我在ARM64平台跑不起来，就不讨论了。</p>
<p>注1：我自己使用Ubuntu18.04，这上面的coccinelle版本很旧，在最新的内核（4.19）上
运行不起来，建议下源代码自行编译。另外注意：coccinelle的configure写得有问题，检
查不到部分开发库不存在的问题，所以如果编译失败，根据名称安装对应的开发库即可。</p>
</div>
</div>
<div class="section" id="autofdo-arm">
<h2><a class="reference external" href="mailto:AutoFDO&#37;&#52;&#48;ARM">AutoFDO<span>&#64;</span>ARM</a><a class="headerlink" href="#autofdo-arm" title="永久链接至标题">¶</a></h2>
<p>演讲416做了一个关于在ARM平台上使用perf的介绍，除了有一些基本的如何使用perf的知
识以外，特别介绍了使用基于perf使用CoreSight（注1）等ARM专有功能。</p>
<p>但我比较感兴趣的是里面关于AutoFDO的例子。</p>
<p>所谓FDO，是gcc等编译器的一个特性，Feedback-DirectedOptimization(link)。编译程
序有一个很难处理的问题是如何判断代码的分支是跳转还是不跳转（这东西影响流水线）
，芯片OoO（Out-of-Order，预测执行）设计很大程度上也是为了解决这个问题。FDO的方
法是编译器先编译一个Instrumented版本（加通过gcov技术），运行一次，收集到所有的
跳转数据了(在.gcda文件中），用这个数据来判断跳转的可能性是怎么样的，然后再用这
个数据生成一个优化过的版本，正式使用。</p>
<p>下面是我在我的桌面机器上用这个技术运行gcc的例子的结果。编译过程如下：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>BN=bubble
ALL=$(BN)_o0$(BN)_o3$(BN)_fdo

all:$(ALL)

$(BN)_o0:$(BN).c
        gcc$&lt;-o$@

$(BN)_o3:$(BN).c
        gcc-O3$&lt;-o$@

$(BN)_inst:$(BN).c
        gcc-fprofile-generate$&lt;-o$@

$(BN).gcda:$(BN)_inst
        ./$(BN)_inst

$(BN)_fdo:$(BN).c$(BN).gcda
        gcc-O3-fprofile-use=$(BN).gcda$&lt;-o$@

test:$(ALL)
        ./$(BN)_o0
        ./$(BN)_o3
        ./$(BN)_fdo

clean:
        rm-f$(ALL)$(BN)_inst*.gcda*.gcno

.PHONY:testclean
</pre></div>
</div>
<p>结果如下：:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./</span><span class="n">bubble_o0</span>
<span class="n">Bubblesortingarrayof30000elements</span>
<span class="mi">3060</span><span class="n">ms</span>
<span class="o">./</span><span class="n">bubble_o3</span>
<span class="n">Bubblesortingarrayof30000elements</span>
<span class="mi">1477</span><span class="n">ms</span>
<span class="o">./</span><span class="n">bubble_fdo</span>
<span class="n">Bubblesortingarrayof30000elements</span>
<span class="mi">1161</span><span class="n">ms</span>
</pre></div>
</div>
<p>对于这种算法类的程序（段），还是很有效果的。</p>
<p>FDO的最大缺点是代价很高，你没法拿一个-fprofile的版本直接到工作环境里面去用。但
perf是没有这个问题的。所以，gcc还推出一个特性，叫AutoFDO（应该是Google提出来的
，这个东西特别适合数据中心），它是用perf数据生成需要的.gcda文件，这样我们很容易
在工作环境中拿到对应的数据了。</p>
<p>AutoFDO依赖于PMU的这个特性：PERF_SAMPLE_BRANCH_STACK。简单说，就是branch事件要
分taken和untaken独立记录。现在很多ARMSoC不支持这个特性。演讲416提出的解决方案是
用CoreSight来解决这个问题。</p>
<p>我要想要的解决方案不是这样的，我想要的解决方案是推动所有服务器SoC供应商把这个作
为标准特性来提供。</p>
<p>注1：CoreSight是一个硬件跟踪器，自带内存，内置在SoC中（很多ARMSoC实现中都有）
，它可以直接从硬件的角度跟踪事件，我感觉对芯片设计师的作用大于软件设计师。用法
和不同的perfrecord/report的模式基本上是一样的。</p>
</div>
<div class="section" id="id2">
<h2>其他<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>最后补充一些零碎的关注点：</p>
<ul>
<li><dl class="first docutils">
<dt><a class="reference external" href="https://lkft.linaro.org/">https://lkft.linaro.org/</a>，ARM世界的功能测试，进展太慢了，到现在连块服务器单</dt>
<dd><p class="first">板都没有104中ARM总结了一下Aarch8的特性引入时间，感觉挺有助于记忆的，我贴上来
：</p>
<blockquote class="last">
<div><div class="figure">
<img alt="../_images/lkft.jpg" src="../_images/lkft.jpg" />
</div>
</div></blockquote>
</dd>
</dl>
</li>
<li><p class="first">Home - Akraino Edge Stack，ARM热推的“雾计算”的一个实现，我觉得是一个卖轻量级
服务器的市场</p>
</li>
<li><p class="first">212中介绍TI在switchdev上的进展，我看到有趣的地方是，有可能以后我
们就不要做网卡了，直接做个交换机进去，host端的网卡都是虚拟出来的，连着一个内
置的交换机，物理端口是对外连的，这样对内部网络的加速就很容易做了</p>
</li>
<li><p class="first">221：kernkonzept/l4re-core，L4Re来做了一个介绍，这个东西和libOS是两条路，
libOS是Linux做主管理，虚拟机跑嵌入式。L4Re是Hypervisor做主管理，Linux做子功能
。还在车载系统上用什么的同学可以考虑看看</p>
</li>
<li><p class="first">223：简单入门了一把怎么用slang写工具，这个我其实特有兴趣，因为理论上编译器已
经做了词法和语法分析，如果我要用其中的信息，应该可以在这个基础上加一点点代码
就可以了。不过我看了一把，就没有什么兴趣了，虽然它确实符合我的要求。但这个“加
一点点代码”还是很费脑子的，不是专门搞这一块的，耗不起这时间。不过偶尔用clang
-Xclang -ast-dump -c test.c加上python简单处理一些东西还是可以的。</p>
</li>
<li><p class="first">404提到未来devtree的一个发展方向，要加上一个语法定义文件了，过去devtree的自由
度太高，定义了无效的，对不上的变量，要运行才能发现。这个方案提供了一个yaml定
义问题，在编译内核的时候用make dt_binding_check检查所有的dts文件描述是否有问
题。这个设计其实如果结合coccinelle等发展方向来考虑，就会发现，其实下一代语言
的发展方向可以逐步会走向DSL，形式验证等技术估计也得像这个方向走才有出路。而发
明新的编程语言和操作系统，反而感觉是重建匹配曲线，成功的机会更加渺茫</p>
</li>
<li><p class="first">405提到了OpenJDK11的发布（半年一个版本，3月发布了10,9月发布11，没毛病），其中
谈到一个重要的特性是GC的优化，在ARM上使用了TBI技术（Top Byte Ignore，就是64位
指针的最高字节反正用不上，用来放其他信息），占用其中四位来表示内存的状态（
remapped, fnalized, 2xMarked），这一看就省了不少GC的指针数据结构，希望可以看
到性能的提升。</p>
</li>
</ul>
<p>主要就是这些了，这个系列到此为止。</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="理解关联.html" class="btn btn-neutral float-right" title="理解关联" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="从香农熵谈设计文档写作.html" class="btn btn-neutral float-left" title="从香农熵谈设计文档写作" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Kenneth Lee

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>