

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>地址空间的故事 &mdash; MySummary 1.0 文档</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="工作和读书有什么不同" href="工作和读书有什么不同.html" />
    <link rel="prev" title="Linux发行版的库软件包组织" href="Linux发行版的库软件包组织.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../README.html" class="icon icon-home"> MySummary
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../道德经直译/README.html">《道德经》直译</a></li>
<li class="toctree-l1"><a class="reference internal" href="../花朵的温室/README.html">花朵的温室</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="README.html">软件架构设计</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="从单元测试理解软件.html">从单元测试理解软件</a></li>
<li class="toctree-l2"><a class="reference internal" href="名可名.html">名可名</a></li>
<li class="toctree-l2"><a class="reference internal" href="小国寡民.html">小国寡民</a></li>
<li class="toctree-l2"><a class="reference internal" href="需求分析的中心思路.html">需求分析的中心思路</a></li>
<li class="toctree-l2"><a class="reference internal" href="关于自然语言编程的方向问题.html">关于自然语言编程的方向问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="反者道之动——欣赏架构设计的基本逻辑.html">反者道之动——欣赏架构设计的基本逻辑</a></li>
<li class="toctree-l2"><a class="reference internal" href="让代码变立体.html">让代码变立体</a></li>
<li class="toctree-l2"><a class="reference internal" href="生成优秀的架构.html">生成优秀的架构</a></li>
<li class="toctree-l2"><a class="reference internal" href="分支设计要领.html">分支设计要领</a></li>
<li class="toctree-l2"><a class="reference internal" href="怎样做项目管理.html">怎样做项目管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="谈谈子女教育问题.html">谈谈子女教育问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="两种基本的构架表述方法.html">两种基本的构架表述方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="弱者道之用——谈技术工作中的守弱问题.html">弱者道之用——谈技术工作中的守弱问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="在Linux下做性能分析.html">在Linux下做性能分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="架构设计的0层逻辑.html">架构设计的0层逻辑</a></li>
<li class="toctree-l2"><a class="reference internal" href="解耦设计.html">解耦设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="怎么做高层设计.html">怎么做高层设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="理解架构版本.html">理解架构版本</a></li>
<li class="toctree-l2"><a class="reference internal" href="PCIE总线的保序模型.html">PCIE总线的保序模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="做与不做都是战略.html">做与不做都是战略</a></li>
<li class="toctree-l2"><a class="reference internal" href="海洋战术式的软件设计方法.html">海洋战术式的软件设计方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="解耦和不解耦.html">解耦和不解耦</a></li>
<li class="toctree-l2"><a class="reference internal" href="再谈“守弱”.html">再谈“守弱”</a></li>
<li class="toctree-l2"><a class="reference internal" href="互斥算法设计.html">互斥算法设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="英文版本的“弱者道之用”.html">英文版本的“弱者道之用”</a></li>
<li class="toctree-l2"><a class="reference internal" href="什么是“守”.html">什么是“守”</a></li>
<li class="toctree-l2"><a class="reference internal" href="从用户功能开始构架系统框架.html">从用户功能开始构架系统框架</a></li>
<li class="toctree-l2"><a class="reference internal" href="Linux发行版的库软件包组织.html">Linux发行版的库软件包组织</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">地址空间的故事</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">段寻址</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">页寻址</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">进程空间</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">进程的内核空间</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asid">ASID</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dma">DMA</a></li>
<li class="toctree-l3"><a class="reference internal" href="#iommusmmu">IOMMU和SMMU</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mmusmmu">两层MMU和SMMU</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">从设备侧发起缺页</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">统一内存模型</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">小结</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="工作和读书有什么不同.html">工作和读书有什么不同</a></li>
<li class="toctree-l2"><a class="reference internal" href="怎样快速调试Linux内核.html">怎样快速调试Linux内核</a></li>
<li class="toctree-l2"><a class="reference internal" href="架构设计中的“少了”和“多了”的问题.html">架构设计中的“少了”和“多了”的问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="Linux iommu和vfio概念空间解构.html">Linux iommu和vfio概念空间解构</a></li>
<li class="toctree-l2"><a class="reference internal" href="怎样做代码Review.html">怎样做代码Review</a></li>
<li class="toctree-l2"><a class="reference internal" href="怎样做客户访谈.html">怎样做客户访谈</a></li>
<li class="toctree-l2"><a class="reference internal" href="RancherOS架构分析.html">RancherOS架构分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="再谈什么是软件架构.html">再谈什么是软件架构</a></li>
<li class="toctree-l2"><a class="reference internal" href="大道曰守，当时曰行.html">大道曰守，当时曰行</a></li>
<li class="toctree-l2"><a class="reference internal" href="不为天下先.html">不为天下先</a></li>
<li class="toctree-l2"><a class="reference internal" href="关于AI的胡说八道.html">关于AI的胡说八道</a></li>
<li class="toctree-l2"><a class="reference internal" href="学习本质？.html">学习本质？</a></li>
<li class="toctree-l2"><a class="reference internal" href="“设计的流程”和“代码的流程”.html">“设计的流程”和“代码的流程”</a></li>
<li class="toctree-l2"><a class="reference internal" href="概要设计不是代码.html">概要设计不是代码</a></li>
<li class="toctree-l2"><a class="reference internal" href="“病病”.html">“病病”</a></li>
<li class="toctree-l2"><a class="reference internal" href="关于架构师的爱恨情仇——《黑客帝国》世界观解读.html">关于架构师的爱恨情仇——《黑客帝国》世界观解读</a></li>
<li class="toctree-l2"><a class="reference internal" href="vfio-mdev逻辑空间分析.html">vfio-mdev逻辑空间分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="Linux Socket 0拷贝特性.html">Linux Socket 0拷贝特性</a></li>
<li class="toctree-l2"><a class="reference internal" href="用户态DMA的问题.html">用户态DMA的问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="Multiprocess Support for Linux IOMMU driver.html">Multiprocess Support for Linux IOMMU driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="Linux RAS特性分析.html">Linux RAS特性分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="写论文.html">写论文</a></li>
<li class="toctree-l2"><a class="reference internal" href="基于“语义”编程.html">基于“语义”编程</a></li>
<li class="toctree-l2"><a class="reference internal" href="从学习assert的用法开始理解如何写“专业的程序”.html">从学习assert的用法开始理解如何写“专业的程序”</a></li>
<li class="toctree-l2"><a class="reference internal" href="架构的存在性.html">架构的存在性</a></li>
<li class="toctree-l2"><a class="reference internal" href="Makefile概念入门.html">Makefile概念入门</a></li>
<li class="toctree-l2"><a class="reference internal" href="ARM服务器进展小结.html">ARM服务器进展小结</a></li>
<li class="toctree-l2"><a class="reference internal" href="怎么做初步的需求分析.html">怎么做初步的需求分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="关于设计方案中的逻辑链问题.html">关于设计方案中的逻辑链问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="从逻辑链问题讨论怎么做高层设计.html">从逻辑链问题讨论怎么做高层设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="工程逻辑链.html">工程逻辑链</a></li>
<li class="toctree-l2"><a class="reference internal" href="为什么你会在你的数据中心中部署ARM服务器.html">为什么你会在你的数据中心中部署ARM服务器</a></li>
<li class="toctree-l2"><a class="reference internal" href="如何为libvirt设置虚拟主机.html">如何为libvirt设置虚拟主机</a></li>
<li class="toctree-l2"><a class="reference internal" href="给普通人解释Spectre和Meltdown安全漏洞.html">给普通人解释Spectre和Meltdown安全漏洞</a></li>
<li class="toctree-l2"><a class="reference internal" href="给程序员解释Spectre和Meltdown漏洞.html">给程序员解释Spectre和Meltdown漏洞</a></li>
<li class="toctree-l2"><a class="reference internal" href="Is retpoline really safe.html">Is retpoline really safe?</a></li>
<li class="toctree-l2"><a class="reference internal" href="逻辑链，道，学和架构工作的本质.html">逻辑链，道，学和架构工作的本质</a></li>
<li class="toctree-l2"><a class="reference internal" href="Serverless是什么——谈如何捕获一个特性的架构本质.html">Serverless是什么——谈如何捕获一个特性的架构本质</a></li>
<li class="toctree-l2"><a class="reference internal" href="道法自然.html">道法自然</a></li>
<li class="toctree-l2"><a class="reference internal" href="自然，守弱和Plan B.html">自然，守弱和Plan B</a></li>
<li class="toctree-l2"><a class="reference internal" href="守弱的内涵和外延.html">守弱的内涵和外延</a></li>
<li class="toctree-l2"><a class="reference internal" href="找到道法自然的“度”.html">找到道法自然的“度”</a></li>
<li class="toctree-l2"><a class="reference internal" href="Specification的写法问题.html">Specification的写法问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="小姐和丫鬟的故事.html">小姐和丫鬟的故事</a></li>
<li class="toctree-l2"><a class="reference internal" href="知不知.html">知不知</a></li>
<li class="toctree-l2"><a class="reference internal" href="PCIE总线的地址问题.html">PCIE总线的地址问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="气和深度学习.html">气和深度学习</a></li>
<li class="toctree-l2"><a class="reference internal" href="单元测试的效果问题.html">单元测试的效果问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="Requirement Analyzing vs. Voting.html">Requirement Analyzing vs. Voting</a></li>
<li class="toctree-l2"><a class="reference internal" href="抽离设计逻辑.html">抽离设计逻辑</a></li>
<li class="toctree-l2"><a class="reference internal" href="盗夸.html">盗夸</a></li>
<li class="toctree-l2"><a class="reference internal" href="抽象还是不抽象的问题.html">抽象还是不抽象的问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="Tegra TX2一瞥.html">Tegra TX2一瞥</a></li>
<li class="toctree-l2"><a class="reference internal" href="Progress and confusion of the IOMMU name space.html">Progress and confusion of the IOMMU name space</a></li>
<li class="toctree-l2"><a class="reference internal" href="一样还是不一样.html">一样还是不一样</a></li>
<li class="toctree-l2"><a class="reference internal" href="运营还是交付.html">运营还是交付</a></li>
<li class="toctree-l2"><a class="reference internal" href="科普一下GPL和开源软件.html">科普一下GPL和开源软件</a></li>
<li class="toctree-l2"><a class="reference internal" href="怎么确定道.html">怎么确定道</a></li>
<li class="toctree-l2"><a class="reference internal" href="回调还是直调.html">回调还是直调</a></li>
<li class="toctree-l2"><a class="reference internal" href="接口的封装层次问题.html">接口的封装层次问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="git的基本架构欣赏.html">git的基本架构欣赏</a></li>
<li class="toctree-l2"><a class="reference internal" href="让设计自生.html">让设计自生</a></li>
<li class="toctree-l2"><a class="reference internal" href="架构控制的从权问题.html">架构控制的从权问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="设计的需求问题.html">设计的需求问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="性能优化的目标问题.html">性能优化的目标问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="加速器和其他硬件的区别.html">加速器和其他硬件的区别</a></li>
<li class="toctree-l2"><a class="reference internal" href="君子与其练达不若朴鲁与其曲谨不若疏狂.html">君子与其练达不若朴鲁与其曲谨不若疏狂</a></li>
<li class="toctree-l2"><a class="reference internal" href="有无之道——一个新的软件架构定义.html">有无之道——一个新的软件架构定义</a></li>
<li class="toctree-l2"><a class="reference internal" href="什么是管理.html">什么是管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="从香农熵谈设计文档写作.html">从香农熵谈设计文档写作</a></li>
<li class="toctree-l2"><a class="reference internal" href="YVR18资料关注点.html">YVR18资料关注点</a></li>
<li class="toctree-l2"><a class="reference internal" href="理解关联.html">理解关联</a></li>
<li class="toctree-l2"><a class="reference internal" href="如何撰写技术交底书.html">如何撰写技术交底书</a></li>
<li class="toctree-l2"><a class="reference internal" href="infiniband概念空间分析.html">infiniband概念空间分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="再谈什么是高层设计.html">再谈什么是高层设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="再谈“法自然”的设计思路.html">再谈“法自然”的设计思路</a></li>
<li class="toctree-l2"><a class="reference internal" href="设计规范.html">设计规范</a></li>
<li class="toctree-l2"><a class="reference internal" href="开源交付.html">开源交付</a></li>
<li class="toctree-l2"><a class="reference internal" href="道纪.html">道纪</a></li>
<li class="toctree-l2"><a class="reference internal" href="X86上的ARM Linux调试环境.html">X86上的ARM Linux调试环境</a></li>
<li class="toctree-l2"><a class="reference internal" href="IOMMU的现状和发展.html">IOMMU的现状和发展</a></li>
<li class="toctree-l2"><a class="reference internal" href="单元测试的强与弱问题.html">单元测试的强与弱问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="做事，做名，绩效主义，以及架构战略.html">做事，做名，绩效主义，以及架构战略</a></li>
<li class="toctree-l2"><a class="reference internal" href="没有规则的规则.html">没有规则的规则</a></li>
<li class="toctree-l2"><a class="reference internal" href="大成若缺.html">大成若缺</a></li>
<li class="toctree-l2"><a class="reference internal" href="非易失内存随想.html">非易失内存随想</a></li>
<li class="toctree-l2"><a class="reference internal" href="参考平台.html">参考平台</a></li>
<li class="toctree-l2"><a class="reference internal" href="一个例子：名的边界效应.html">一个例子：名的边界效应</a></li>
<li class="toctree-l2"><a class="reference internal" href="抽象问题的模型.html">抽象问题的模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="另一个例子：名的边界效应.html">另一个例子：名的边界效应</a></li>
<li class="toctree-l2"><a class="reference internal" href="Zircon架构简单分析1: Overview.html">Zircon架构简单分析1: Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="在qemu中模拟设备.html">在qemu中模拟设备</a></li>
<li class="toctree-l2"><a class="reference internal" href="国产操作系统问题.html">国产操作系统问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="软件飞线.html">软件飞线</a></li>
<li class="toctree-l2"><a class="reference internal" href="状态机方法.html">状态机方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="一些典型的架构设计错误.html">一些典型的架构设计错误</a></li>
<li class="toctree-l2"><a class="reference internal" href="从CPU和TPU的不同语言抽象看抽象原则.html">从CPU和TPU的不同语言抽象看抽象原则</a></li>
<li class="toctree-l2"><a class="reference internal" href="限制管理.html">限制管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="WarpDrive as a General Heterogeneous Platform.html">WarpDrive as a General Heterogeneous Platform</a></li>
<li class="toctree-l2"><a class="reference internal" href="Multiarch概念调查.html">Multiarch概念调查</a></li>
<li class="toctree-l2"><a class="reference internal" href="ARM NUC.html">ARM NUC</a></li>
<li class="toctree-l2"><a class="reference internal" href="UML有没有用.html">UML有没有用</a></li>
<li class="toctree-l2"><a class="reference internal" href="推演一个Buffer分配的语法设计.html">推演一个Buffer分配的语法设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="架构师和项目经理的基本职责问题.html">架构师和项目经理的基本职责问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="锁使用设计.html">锁使用设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="从内核终止用户态程序的IO访问.html">从内核终止用户态程序的IO访问</a></li>
<li class="toctree-l2"><a class="reference internal" href="epoll和select.html">epoll和select</a></li>
<li class="toctree-l2"><a class="reference internal" href="状态机退出方法.html">状态机退出方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="不为天下先2.html">不为天下先2</a></li>
<li class="toctree-l2"><a class="reference internal" href="设计逻辑和代码逻辑.html">设计逻辑和代码逻辑</a></li>
<li class="toctree-l2"><a class="reference internal" href="流水线深度.html">流水线深度</a></li>
<li class="toctree-l2"><a class="reference internal" href="谁是主线？.html">谁是主线？</a></li>
<li class="toctree-l2"><a class="reference internal" href="理解指令集.html">理解指令集</a></li>
<li class="toctree-l2"><a class="reference internal" href="给使用设备的进程发信号.html">给使用设备的进程发信号</a></li>
<li class="toctree-l2"><a class="reference internal" href="Linux设备异常复位逻辑分析.html">Linux设备异常复位逻辑分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="投资开源社区的基本逻辑.html">投资开源社区的基本逻辑</a></li>
<li class="toctree-l2"><a class="reference internal" href="一个Linux死锁信息分析.html">一个Linux死锁信息分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="如何说谎.html">如何说谎</a></li>
<li class="toctree-l2"><a class="reference internal" href="代码生成器.html">代码生成器</a></li>
<li class="toctree-l2"><a class="reference internal" href="弟子规：美国军方禁止在C语言程序中使用malloc.html">弟子规：美国军方禁止在C语言程序中使用malloc</a></li>
<li class="toctree-l2"><a class="reference internal" href="自下而上和自上而下的设计.html">自下而上和自上而下的设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="正面竞争.html">正面竞争</a></li>
<li class="toctree-l2"><a class="reference internal" href="不知为美.html">不知为美</a></li>
<li class="toctree-l2"><a class="reference internal" href="高层封装的设计战略.html">高层封装的设计战略</a></li>
<li class="toctree-l2"><a class="reference internal" href="产业生态的原理和作用.html">产业生态的原理和作用</a></li>
<li class="toctree-l2"><a class="reference internal" href="弯道问题.html">弯道问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="无名概念的深入探讨.html">无名概念的深入探讨</a></li>
<li class="toctree-l2"><a class="reference internal" href="解释On-Chip Debug和Off-Chip Debug.html">解释On-Chip Debug和Off-Chip Debug</a></li>
<li class="toctree-l2"><a class="reference internal" href="接口和名称空间辨识.html">接口和名称空间辨识</a></li>
<li class="toctree-l2"><a class="reference internal" href="RISCV WMO和TSO具体解决什么问题.html">RISCV WMO和TSO具体解决什么问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="利益链.html">利益链</a></li>
<li class="toctree-l2"><a class="reference internal" href="从C的for和Python的for聊起.html">从C的for和Python的for聊起</a></li>
<li class="toctree-l2"><a class="reference internal" href="安全建模问题讨论.html">安全建模问题讨论</a></li>
<li class="toctree-l2"><a class="reference internal" href="Accelerator vs. Co-processor.html">Accelerator vs. Co-processor</a></li>
<li class="toctree-l2"><a class="reference internal" href="一个逻辑空间控制的例子：uacce生命周期管理.html">一个逻辑空间控制的例子：uacce生命周期管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="软件构架设计的入题角度问题.html">软件构架设计的入题角度问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="接口分层的问题.html">接口分层的问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="对Cache Coherence的重理解.html">对Cache Coherence的重理解</a></li>
<li class="toctree-l2"><a class="reference internal" href="接口定义的工作模型.html">接口定义的工作模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="Linux_net和net-next分支的维护策略.html">Linux net和net-next分支的维护策略</a></li>
<li class="toctree-l2"><a class="reference internal" href="WarpDrive用户态方案重构建议.html">WarpDrive用户态方案重构建议</a></li>
<li class="toctree-l2"><a class="reference internal" href="主线逻辑.html">主线逻辑</a></li>
<li class="toctree-l2"><a class="reference internal" href="架构设计的粗与细问题.html">架构设计的粗与细问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="狂人日记读后感——名称空间囚笼.html">狂人日记读后感——名称空间囚笼</a></li>
<li class="toctree-l2"><a class="reference internal" href="写程序和写小说的区别.html">写程序和写小说的区别</a></li>
<li class="toctree-l2"><a class="reference internal" href="再谈《弟子规》问题.html">再谈《弟子规》问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="理解弱内存顺序模型.html">理解弱内存顺序模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="思维上的洞2.html">思维上的洞2</a></li>
<li class="toctree-l2"><a class="reference internal" href="后软件时代和技术沙盘陷阱.html">后软件时代和技术沙盘陷阱</a></li>
<li class="toctree-l2"><a class="reference internal" href="怎么做项目管理2.html">怎么做项目管理2</a></li>
<li class="toctree-l2"><a class="reference internal" href="语言的控制力问题.html">语言的控制力问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="分享我的Linux内核开发环境.html">分享我的Linux内核开发环境</a></li>
<li class="toctree-l2"><a class="reference internal" href="开发视图.html">开发视图</a></li>
<li class="toctree-l2"><a class="reference internal" href="概念视图.html">概念视图</a></li>
<li class="toctree-l2"><a class="reference internal" href="处理视图.html">处理视图</a></li>
<li class="toctree-l2"><a class="reference internal" href="语言控制力问题.html">语言控制力问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="新手设计文档典型错误.html">新手设计文档典型错误</a></li>
<li class="toctree-l2"><a class="reference internal" href="讨论：OpenCL2.0SVM有什么好？.html">讨论：OpenCL2.0SVM有什么好？</a></li>
<li class="toctree-l2"><a class="reference internal" href="设计逻辑的细致和严密问题.html">设计逻辑的细致和严密问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="逻辑的平面和立体问题.html">逻辑的平面和立体问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="自由和约束.html">自由和约束</a></li>
<li class="toctree-l2"><a class="reference internal" href="给非专业人士介绍架构设计工作.html">给非专业人士介绍架构设计工作</a></li>
<li class="toctree-l2"><a class="reference internal" href="AML工作原理快速调研.html">AML工作原理快速调研</a></li>
<li class="toctree-l2"><a class="reference internal" href="qemu_PCIe总线结构.html">qemu PCIe总线结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="ARM64_Linux_Kernel_5.7无法GDB调试问题.html">ARM64 Linux Kernel 5.7无法GDB调试问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="分层抽象.html">分层抽象</a></li>
<li class="toctree-l2"><a class="reference internal" href="见素抱朴：一个关于交付的例子.html">见素抱朴：一个关于交付的例子</a></li>
<li class="toctree-l2"><a class="reference internal" href="三个锦囊.html">三个锦囊</a></li>
<li class="toctree-l2"><a class="reference internal" href="多核MMU和ASID管理逻辑.html">多核MMU和ASID管理逻辑</a></li>
<li class="toctree-l2"><a class="reference internal" href="PMA和PA方案对比.html">PMA和PA方案对比</a></li>
<li class="toctree-l2"><a class="reference internal" href="真假架构设计.html">真假架构设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="怎样写标准提案.html">怎样写标准提案</a></li>
<li class="toctree-l2"><a class="reference internal" href="安全问题的本质.html">安全问题的本质</a></li>
<li class="toctree-l2"><a class="reference internal" href="名称内涵的发展.html">名称内涵的发展</a></li>
<li class="toctree-l2"><a class="reference internal" href="标准和设计的区别.html">标准和设计的区别</a></li>
<li class="toctree-l2"><a class="reference internal" href="cond_mutex模型.html">cond/mutex模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="一个例子：架构的重要性和从权.html">一个例子：架构的重要性和从权</a></li>
<li class="toctree-l2"><a class="reference internal" href="nvdimm_AD模式的内核应用模型.html">nvdimm AD模式的内核应用模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="早期架构设计问题.html">早期架构设计问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="所谓内部设计.html">所谓内部设计</a></li>
<li class="toctree-l2"><a class="reference internal" href="“知不知”如何影响决策的？.html">“知不知”如何影响决策的？</a></li>
<li class="toctree-l2"><a class="reference internal" href="“优秀架构设计”.html">“优秀架构设计”</a></li>
<li class="toctree-l2"><a class="reference internal" href="Linux_Kernel架构赏析.html">Linux Kernel架构赏析</a></li>
<li class="toctree-l2"><a class="reference internal" href="说说对协程的看法.html">说说对协程的看法</a></li>
<li class="toctree-l2"><a class="reference internal" href="架构设计和实施的对齐和同步问题.html">架构设计和实施的对齐和同步问题</a></li>
<li class="toctree-l2"><a class="reference internal" href="一个关于4+1视图的案例：从概念视图开始.html">一个关于4+1视图的案例：从概念视图开始</a></li>
<li class="toctree-l2"><a class="reference internal" href="“硬件状态机”.html">“硬件状态机”</a></li>
<li class="toctree-l2"><a class="reference internal" href="设计的减熵原理.html">设计的减熵原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="binfmt概念空间建模.html">binfmt概念空间建模</a></li>
<li class="toctree-l2"><a class="reference internal" href="架构设计入门知识.html">架构设计入门知识</a></li>
<li class="toctree-l2"><a class="reference internal" href="架构设计的大忌：我没错.html">架构设计的大忌：我没错</a></li>
<li class="toctree-l2"><a class="reference internal" href="“解决方案”.html">“解决方案”</a></li>
<li class="toctree-l2"><a class="reference internal" href="讨论一下eBPF.html">讨论一下eBPF</a></li>
<li class="toctree-l2"><a class="reference internal" href="交付中的Version和Revision.html">交付中的Version和Revision</a></li>
<li class="toctree-l2"><a class="reference internal" href="约束选择.html">约束选择</a></li>
<li class="toctree-l2"><a class="reference internal" href="git-submodule的理解.html">git submodule的理解</a></li>
<li class="toctree-l2"><a class="reference internal" href="思维的串行化要求.html">思维的串行化要求</a></li>
<li class="toctree-l2"><a class="reference internal" href="什么是函数式编程.html">什么是函数式编程</a></li>
<li class="toctree-l2"><a class="reference internal" href="管理上的判断和技术上的判断.html">管理上的判断和技术上的判断</a></li>
<li class="toctree-l2"><a class="reference internal" href="基于逻辑链建立约束.html">基于逻辑链建立约束</a></li>
<li class="toctree-l2"><a class="reference internal" href="高级需求分析.html">高级需求分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="False_Sharing.html">假共享内存(False Sharing)</a></li>
<li class="toctree-l2"><a class="reference internal" href="芯片验证软件的4+1方法.html">芯片验证软件的4+1方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="软件之硬.html">软件之硬</a></li>
<li class="toctree-l2"><a class="reference internal" href="诚其意.html">诚其意</a></li>
<li class="toctree-l2"><a class="reference internal" href="把什么放入架构设计.html">把什么放入架构设计</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Linux主线内核跟踪/README.html">Linux主线内核跟踪</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../README.html">MySummary</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../README.html">Docs</a> &raquo;</li>
        
          <li><a href="README.html">软件架构设计</a> &raquo;</li>
        
      <li>地址空间的故事</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/软件构架设计/地址空间的故事.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>地址空间的故事<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>这一篇聊一下地址空间相关的知识。</p>
<p>每个程序都面对一个或者多个地址空间。你写一个程序，说*(0x1234)=10，这里就索引了
一个地址。所有可以被索引的地址，就构成一个地址空间。一个CPU上的程序可能不止一个
地址空间，比Intel支持LPC的指令，用inX和outX指令索引的地址空间和用movb索引的地址
空间就是两个相对独立的地址空间。有些比如哈佛构架的CPU，访问指令和访问数据内存也
会使用不同的地址空间。</p>
<p>一般冯诺伊曼计算机访问内存的是同一套指令，这套指令构成一个地址空间。CPU的指令集
就通过这个地址空间要求CPU访问内存。</p>
<p>最早的CPU的指令直接索引到物理内存的地址，也就是说，指令说要访问0x1234，访问的就
是物理内存下标为0x1234的那个单元的内容。但我要请读者注意的是，这里其实有两个地
址空间，一个是指令构造的地址空间（我缩写为ia），另一个是物理地址总线上发出的地
址构成的地址空间（我缩写为pa），ia和pa不是完全一一对应的。因为指令的演进具有滞
后性，软件是基于指令集写的，写好了，我希望未来做一个更强大的CPU的时候，不要让我
还要改写软件。所以比如你的物理地址只有10位，你不可能就做一个指令集，里面的地址
都是10位的，以后要支持更多内存，你把物理地址做成11位，你就要重新搞一个指令集。
这样软件就没有演进性了。所以，ia空间是相对稳定的，pa则变化得更快一些。我们后面
说到的所有故事，都和这两者的互相变化引起的。我需要读者非常注意这个问题。</p>
<div class="section" id="id2">
<h2>段寻址<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>PC行业兴起的时候，常常使用16位ia的指令集，16位表示64K的空间，那个时候好大好大了
，因为物理内存通常只有16K或者更低的，这时你如果做了14位的物理内存地址空间，CPU
发一个16位的地址下来，你只要不看最高两位，你就可以寻址了。</p>
<p>但我们对内存的猜测永远是缺乏想象力的（也是节省资源的需要了，这个我另外找地方介
绍），很快物理内存就超过16位了。但立即修改指令集会影响市场，这时，有什么办法扩
展指令集，让ia的空间补到和pa空间可以寻址一样的长度呢？</p>
<p>对了，很自然的想法，加一个寄存器表示地址的高位就可以了：</p>
<blockquote>
<div><div class="figure">
<img alt="../_images/地址空间1.png" src="../_images/地址空间1.png" />
</div>
</div></blockquote>
<p>所以，段地址这种东西，你不要被它那些什么权限啦，内存分段啦这些概念蒙蔽，这就是
个简单的地址扩展方法，至于其他功能，段寄存器不可能做成4位，所以剩下的位，闲着也
是闲着，就加点功能上去，如此而已。</p>
</div>
<div class="section" id="id3">
<h2>页寻址<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>段寻址的缺点是显而易见的，你不可能每次寻址都分两次来加载两个数据，这样太麻烦了
。所以才需要把高位地址封装成“段”的概念，比如x86的意思是，你访问代码用cs寄存器，
访问数据用ds寄存器，这样每次你就不用改这两个寄存器玩了。但这样整个程序也就只有
128K而已，如果我的数据很大，超过64K的范围，就又得切换这东西了，x86说，不够是吗
？我再给你一个es寄存器……好吧，这样和稀泥的方式是玩不久的。</p>
<p>很快MMU的概念就被提出来了。MMU是一个翻译器，ia发出的地址，都经过MMU进行翻译，变
成pa。所以，MMU本质上是一个函数，实现pa=mmuf(ia)。</p>
<p>问题是，MMU基于什么算法来进行翻译？</p>
<p>我们用最“自由”的方式来定义这个算法，最好就是可以指定每个ia的pa是什么。但这样就
需要一张ia空间那么大的表。那么大的表，什么地方可以放得下呢？——也只有内存了。但
内存填满了这么一张表，还放什么呢？</p>
<p>所以一个ia对应一个pa，这个算法在数理逻辑上就不合理。那我们可以退而求其次，每段
连续的ia对应一段连续的pa，这样，这个段的大小，就是可以节省的映射表的项数了。比
如，一个16位的ia，用10位作为一段，那么原来需要64K个映射项，现在只需要64K/1K=64
项而已。</p>
<p>由于每段的大小都固定了，我们把这种段称为“页”。现在很多平台都是用12位作为一页，
所以，现在很多系统都是4K为一页，但这不是固定的，根据需要是可以变的。</p>
<p>基于页寻址的方式，就称为页寻址，实现页寻址的那个映射表，就称为页表，页表放在内
存中。在长期的发展过程中，现在的页表不是一个简单的数组，而是一个分层的数组，这
些细节，读者可以自己看芯片编程手册，但本质都只是为了实现ia到pa的对应，所有的优
化都是为了节省空间而已。</p>
<p>和段寻址一样，既然页表都发明出来了，和页有关的一些保护措施也会依附上去，让一个
页只读啦，决定从这个地址发出去的请求能否合并啦，有没有边界效应啦，这些都可以设
置到页表的对应项中。但仍和段寻址一样，这个问题不是页寻址问题的本质。</p>
<p>页表的存在，导致所有的ia发出的地址和pa没有直接的映射关系了，为了描述的方便，我
们现在开始在这种情形下，把ia称为虚拟地址，va。</p>
</div>
<div class="section" id="id4">
<h2>进程空间<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>有了页寻址，进程的概念很自然就被发明出来了。页表是MMU的输入，那么一个自然的想法
，我们有多个页表，一会儿用这个，一会儿用那个，这样我们可以根据需要用不同的内存
，这个用来表达不同MMU的概念，体现在软件的观感上，就是进程。</p>
<p>当然，MMU封装为进程，还和软件的“线程”概念进行了一定程度上进行了绑定，所以，软件
的进程，不是简单的MMU的封装，但我们在理解寻址的概念的时候，是可以简单这样认为的
。</p>
<p>有了页寻址的概念，进程的空间和物理地址看到的空间就很不一样了：</p>
<blockquote>
<div><div class="figure">
<img alt="../_images/地址空间2.png" src="../_images/地址空间2.png" />
</div>
</div></blockquote>
<p>这样为前面谈到的ia空间和pa空间的不匹配制造不少机会。比如32位的处理器，ia空间是
32位的，但随着发展，内存越来越大，超过ia可以寻址的4G的空间了。但我们只要保证页
表中的pa超过32位，我们就可以让多个进程合起来使用超过4G的物理地址空间。Intel的
PAE就是这样的技术，本质上是扩展页表中pa的范围。</p>
</div>
<div class="section" id="id5">
<h2>进程的内核空间<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>所有从进程发出的va访问，都通过MMU翻译，包括请求从一个进程切换到另一个进程。这样
一来，进程的权力太大了。所以，还是很自然的，我们在MMU中可以设置一个标志，说明某
些地址是具有“更高优先级”的，一般情况下不允许访问，要访问就要提权，一旦提权，代
码执行流就强行切换到这片“高级内存”的特定位置，这样，就给一个进程指定了两个权限
级别，一个是所谓的“用户态”，一个是“内核态”，用户态用于一般的程序，内核态用来做
进程的管理。</p>
<p>用户态和内核态都在同一个页表中管理，所以，本质上，它们属于同一个进程。只是它们
属于进程的不同权限而已。</p>
<p>为了实现的方便，现在通常让所有进程的MMU页表的内核空间指向物理空间的同一个位置，
这样，看起来我们就有了一个独立于所有进程的实体，这个实体被称为“操作系统内核”，
它是管理所有进程的一个中心软件。</p>
<p>其实操作系统内核并不是必须做成全局唯一的，只是这样设计最方便就是了。</p>
<p>内核空间的存在分少了进程的可用空间，本来一个32位进程可以用4G的空间的，但由于要
留一部分给内核用，就不能是4G了。如何切分这个空间，是一个设计上的权衡。给用户空
间切少了，作为以用户程序为中心的操作系统来说，这影响了竞争力。给内核空间切少了
，内核管理上不方便，能力降低。现在Linux在32位系统上通常使用 3G:1G这样的切分关系
。</p>
<p>如果是微内核操作系统，由于内核的功能少，这个比例可以进一步降低，比如我们可以留
1M给内核，其他空间全部留给用户态。这也算是微内核操作系统的一个优势吧。</p>
<p>有人不明白为什么Linux内核中需要有Himem这个概念，这样一看也很好理解了，内核有权
访问所有内存，但它只有1G的虚拟空间，如果你的物理内存不到1G，在它1G的va空间内，
它可以对物理内存做一一映射。但如果你的物理内存超过1G，这种方法就不可行了，你只
能根据需要把不同的物理内存映射进来使用。把线性映射的部分分开，不能线性映射的部
分，我们就称为Himem了。线性映射的部分和Himem在什么地方分解，又是一种权衡。但这
种权衡，老实说，现在我们已经不怎么关心了，因为现在已经切换到64位系统，虚拟空间
高达16EB，分给内核用绰绰有余（实际上，现在大部分64位系统的物理地址只有48位），
内核虚拟地址总是可以线性映射所有的物理地址的。</p>
</div>
<div class="section" id="asid">
<h2>ASID<a class="headerlink" href="#asid" title="永久链接至标题">¶</a></h2>
<p>不知道读者是否考虑过这个问题：页表放在内存中，MMU收到一个地址访问请求，为了做翻
译，它首先要访问内存，得到对应的翻译项，然后再去访问内存。这是不是表示每个地址
访问，其实要访问两次内存？</p>
<p>访问内存是很慢的，MMU显然不会干这种蠢事。所以，它使用了CPU设计者的万能法宝：加
个Cache呗。</p>
<p>MMU的Cache称为TLB，MMU进行翻译的时候，首先从TLB里读页表项，如果页表项不在TLB中
，再读内存，把内存中的对应项写到TLB中，然后在用TLB中的数据进行翻译，这样就不用
每次做翻译都要读一次内存了。</p>
<p>这样的算法可以得以实施，取决于一个现实，称为程序的局部性原理，即假设程序在一段
时间内，访问的都是特定范围内的内存，这样MMU就不用经常重新加载TLB了。</p>
<p>但这个局部性原理在特定的场景上是不成立的，一种情形是大型数据库。数据库有个很大
的表在内存中，经常要跨越页进行随机访问，这样就有很大的机会造成TLB失效（这种情形
称为Cache污染），操作系统解决这个问题的方法常常是使用HugePage，也就是让特定的页
不止4K，比如可以是256M，这样，256M的内存仅仅需要一个TLB项，甚至可以把这个TLB项
锁死在TLB中（不允许替换），这样数据库的性能就可以提高。</p>
<p>第二个影响局部性原理的场景是微内核操作系统。微内核操作系统不从内核请求操作系统
服务（微内核操作系统的内核仅仅提供进程切换和进程间通讯手段），而是直接从另一个
进程获得这个服务，这大大提高了进程切换的频度。问题是，A进程向B进程发出一个请求
，B进程1ms就搞定了，又切换回A进程。但你切换进程，我就得把整个TLB清掉，所以，为
了这个1ms的请求，MMU就得重新加载进程A需要的所有页表项，这个对性能的影响也太大了
。</p>
<p>解决这个问题的方法是引入ASID，也就是让MMU认识进程id。所以，在TLB的表项中，每个
项都有一个ASID，当你切换进程的时候，你不需要清空TLB的，B进程用不了里面A进程的页
表项，这样你切换回A进程的时候就不需要重新加载对应的项了。</p>
<p>ASID这个概念在我们后面讨论IOMMU/SMMU的时候有特别的作用。</p>
</div>
<div class="section" id="dma">
<h2>DMA<a class="headerlink" href="#dma" title="永久链接至标题">¶</a></h2>
<p>好了，CPU和内存的恩怨告一段落了。现在我们该看看外设了。Intel最早的时候给了外设
独立的地址空间， 要访问外设就用io指令，独立指定要访问的地址，和内存访问没有关系
。但这样划分没有什么意义，所以现代的CPU通常把这两个地址空间合并。只是在做页表映
射的时候，给外设空间特殊的设定（比如内存读，如果要求读一个字节，我读64个字节也
不会有错，但外设就不行了，所以要进行特殊的设定）。</p>
<p>读写外设空间是个很慢的动作，因为从总线上发出一个读写操作，都要等被读写一方响应
的，CPU做了很多优化来优化内存访问的QoS，但对外设是没有什么办法的（这玩意儿可以
动态插进来的，没法做任何假设），所以，遇到一个不好的设备，进行io读写，可以导致
整个指令停住不能动。</p>
<p>现在更常见的方法是尽量不去碰外设的IO空间，而是把数据放在内存中，让外设自己去读
。这个动作就称为DMA，现代SoC中外设用来访问内存的部件，通常就叫DMA控制器。</p>
<p>早期的外设通常很简陋，它自己的DMA访问内存的总线常常比CPU的物理总线要短。比如你
一个32位的CPU，物理总线是40位，但外设的DMA就只有16位。这样如果CPU发起一个DMA请
求，让外设自己去读一个超过16位的物理内存地址的空间，这个外设根本就没有能力访问
。</p>
<p>为了解决这个问题，Linux内核为驱动提供了DMA专门的内存分配函数。保证你分配的空间
在外设DMA可以访问的范围内（这就是内核分区ZONE_DMA的由来），这样，你做DMA就能保
证这个物理地址是可以被外设访问到的。</p>
<p>现在的外设越来越强了，很多外设的DMA都拥有和CPU一样长的地址，对于这样的设备，就
不需要用那个分配函数来解决问题了。</p>
</div>
<div class="section" id="iommusmmu">
<h2>IOMMU和SMMU<a class="headerlink" href="#iommusmmu" title="永久链接至标题">¶</a></h2>
<p>外设没有MMU，所以CPU要提供一个地址给外设访问，必须使用物理地址。但使用物理地址
是件很麻烦的事情，因为在虚拟地址上连续的地址，在物理地址上不一定连续。</p>
<p>所以，又作为一个“自然”的想法，有人就考虑把MMU移到设备DMA上来，这个概念就是IOMMU
（AMD的概念）和SMMU（ARM的概念）了。由于我对ARM比较熟一点，我们用SMMU举例。</p>
<p>SMMU的原理和MMU一样，只是作用在设备一侧，SMMU可以复用MMU的页表，也可以自己创建
页表。通常我们不会选择复用页表，因为SMMU是针对每个设备的，我们显然希望设备只看
到CPU希望给它看到的空间，而不是所有空间，否则一不小心我们插一个黑客设备进来，整
个操作系统就暴露了。</p>
<p>有了SMMU，我们对外设做DMA请求，就不需要使用物理地址了，使用和进程一样的虚拟地址
就可以了。只要保证SMMU的页表中对应的设置和进程一致就行。Linux内核中做DMA请求之
前，要求做dma_map，就是为了完成SMMU的对应设置。</p>
<p>实际上，SMMU的问题比MMU的问题复杂。考虑这么一种情况：进程A发起一个DMA请求，我们
把这个页表项放到设备的SMMU上了，现在CPU切换到进程B，CPU的页表变了，但设备不知道
啊，设备还是向当初的虚拟地址上写。这时进程B又发起一个DMA请求，在同一个虚拟地址
上要求做DMA，设备不是晕菜了？</p>
<p>为了解决这个问题，那个ASID又被捡起来了，SMMU的页表中带上ASID，这样，CPU一个时刻
只有一个进程的页表在用，而设备却同时用着好多的页表。</p>
</div>
<div class="section" id="mmusmmu">
<h2>两层MMU和SMMU<a class="headerlink" href="#mmusmmu" title="永久链接至标题">¶</a></h2>
<p>MMU和SMMU的概念在虚拟化时代继续进行着演进。如果用户程序运行在虚拟机中会怎么样？
ARMv7/v8提供两层地址映射，虚拟机中的程序发出一个va，第一次翻译为ipa（中间pa），
如果下面是虚拟机创建的，虚拟机也可以给MMU/SMMU指定一个页表，说明ipa如何翻译为pa
。这样，虚拟机的效率就提高了，硬件就认知了虚拟机的概念。va一次使用两层的页表，
直接得到pa。这种情况下，实际上就有进程，Hypervisor和物理三个地址空间了。</p>
<p>问题是，如果我要在虚拟机里面再跑一个虚拟机怎么办呢？这个方案也在做。显然我们不
能无限增加MMU/SMMU的翻译层数了，所以就只能在Hypervisor的调度上下功夫，虚拟机的
页表根据Hypervisor的调度进行动态的切换。类似这样：</p>
<blockquote>
<div><div class="figure">
<img alt="../_images/地址空间3.png" src="../_images/地址空间3.png" />
</div>
</div></blockquote>
</div>
<div class="section" id="id6">
<h2>从设备侧发起缺页<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<p>设备使用虚拟地址，又再带来一个问题，根据现代操作系统的管理方式，虚拟地址很可能
是没有分配物理空间的，在CPU一侧如果发生这种事情，就通过缺页例程来解决。但在设备
侧怎么办呢？</p>
<p>一种简单的方法是发起DMA前，把虚拟空间先pin死到物理内存中。</p>
<p>但这样是有缺点的，因为如果一大片内存给了设备，设备只需要一头一尾两页的内存呢？
那我不是白干了？</p>
<p>所以，更好的办法是让设备也有缺页的能力。但设备缺页是比CPU缺页复杂的。CPU缺页你
只要在缺页中断中把页加载进来。但设备缺页，设备可没有能把缺掉的页加载进来。所以
，CPU上需要一个代理（在PCIE的ATS标准中称为TA，转换代理），设备上进行页面转换的
装置（称为ATC，地址转化客户端）在发现缺页的时候，通过对TA发送缺页信息，让TA通知
CPU产生设备缺页中断，然后把对应的LTB项发送给ATC，才能继续下去。</p>
<p>x86在Linux中加入svm框架来处理这个过程（参考Linux内核代码中的
driver/iommu/intel-svm.c），ARM也在准备合入到这个框架中（参考：
<a class="reference external" href="http://www.spinics.net/lists/linux-pci/msg58650.html">http://www.spinics.net/lists/linux-pci/msg58650.html</a>）。其实SVM是个比较容易搞定
的事情，这个设计的主要难度在总线系统上，CPU的缺页到异常的过程几乎是原子或者同步
的，但如果总线系统要经过几次消息交换来完成这个过程，就有很多出错的机会了。。</p>
</div>
<div class="section" id="id7">
<h2>统一内存模型<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<p>把上面的考虑综合在一起，我们发现我们逐步走向一种“全局地址”的内存模型了，也就是
说，要加工的数据，统统放在内存里，CPU来动一部分，GPU来动一部分，FPGA来动一部分
，硬加速加速器来动一部分。</p>
<p>这个设计，就叫“统一内存模型”，ARM联盟的CCIX，HPE的Gen-Z，现在都在为最终的这种模
型填砖加瓦，这也是我们未来追求的统一异构计算的软件模型。</p>
<p>所谓CCIX，其实是是PCIE的一个变种，PCIE总线的协议栈分4层，应用，会话，链路和物理
。CCIX替换了其中的应用层和部分的会话层，实现可以深度不是那么深，但对于内存是
Cache Coherence的高速外设总线。从而让基于CCIX的外设可以用更方便简单的方法修改加
入内存的协同访问中。</p>
<p>而Gen-Z，是通过一个Fabric访问更大的，非CC的内存，让全局的系统可以访问到更大的内
存空间（比如256T）。</p>
</div>
<div class="section" id="id8">
<h2>小结<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<p>我们这个文档，我用得最多的一个描述，可能是“很自然……”，所以，说“道法自然”，确实
是有事实依据的：）</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="工作和读书有什么不同.html" class="btn btn-neutral float-right" title="工作和读书有什么不同" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Linux发行版的库软件包组织.html" class="btn btn-neutral float-left" title="Linux发行版的库软件包组织" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Kenneth Lee

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>